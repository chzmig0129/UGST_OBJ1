{% extends 'base.html' %}

{% block content %}
<div class="validacion-container">
    <div class="section-header">
        <div class="d-flex align-items-center">
            <div class="app-icon">
                <svg viewBox="0 0 24 24" width="28" height="28" stroke="currentColor" stroke-width="2" fill="none">
                    <polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"></polygon>
                    <line x1="8" y1="2" x2="8" y2="18"></line>
                    <line x1="16" y1="6" x2="16" y2="22"></line>
                </svg>
            </div>
            <div>
                <h1 class="mb-0">Validación de Polígonos</h1>
                <p class="text-muted mb-0">Gestione, valide y genere fichas técnicas para sus polígonos</p>
            </div>
        </div>
    </div>

    <!-- Pestañas de navegación -->
    <div class="tabs-container">
        <div class="nav-tabs">
            <a href="{{ url_for('validacion_poligonos', tab='cargar') }}" class="tab-item {% if tab == 'cargar' %}active{% endif %}">
                Cargar Datos
            </a>
            <a href="{{ url_for('validacion_poligonos', tab='lista') }}" class="tab-item {% if tab == 'lista' %}active{% endif %}">
                Lista de Polígonos
            </a>
            <a href="{{ url_for('validacion_poligonos', tab='editar') }}" class="tab-item {% if tab == 'editar' %}active{% endif %}">
                Editar Polígono
            </a>
            <a href="{{ url_for('validacion_poligonos', tab='generar') }}" class="tab-item {% if tab == 'generar' %}active{% endif %}">
                Generar Fichas
            </a>
        </div>
    </div>

    <!-- Mensajes flash -->
    {% with messages = get_flashed_messages() %}
        {% if messages %}
            <div class="flash-messages">
                {% for message in messages %}
                <div class="alert alert-info alert-dismissible fade show">
                    {{ message }}
                    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                </div>
                {% endfor %}
            </div>
        {% endif %}
    {% endwith %}

    <!-- Contenido de las pestañas -->
    <div class="tab-content">
        {% if tab == 'cargar' %}
        <!-- Pestaña de Cargar Datos -->
        <div class="card">
            <div class="card-body">
                <h3 class="mb-4">Cargar archivo Excel</h3>
                
                {% if filename %}
                <div class="alert alert-success mb-3">
                    Archivo actual: <strong>{{ filename }}</strong>
                    {% if uploaded_columns %}
                    <br>Columnas detectadas: {{ uploaded_columns|join(', ') }}
                    {% endif %}
                </div>
                {% endif %}
                
                <form action="{{ url_for('cargar_excel') }}" method="post" enctype="multipart/form-data">
                    <div class="input-group mb-3">
                        <input type="file" class="form-control" id="archivo" name="archivo" accept=".xlsx,.xls" required>
                        <button class="btn btn-primary" type="submit">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="7 10 12 15 17 10"></polyline>
                                <line x1="12" y1="15" x2="12" y2="3"></line>
                            </svg>
                            Cargar
                        </button>
                    </div>
                </form>
                
                <div class="formato-info mt-4">
                    <h4>Instrucciones:</h4>
                    <ul>
                        <li>Puede subir cualquier archivo Excel (.xlsx o .xls)</li>
                        <li>El sistema detectará automáticamente las columnas</li>
                        <li>No es necesario un formato específico</li>
                        <li>Los datos se mantendrán en memoria mientras la aplicación esté en ejecución</li>
                    </ul>
                </div>
            </div>
        </div>
        
        {% elif tab == 'lista' %}
        <!-- Pestaña de Lista de Polígonos -->
        <style>
            .table-responsive-custom {
                /* Personalizar scrollbar para webkit browsers */
                scrollbar-width: thin;
                scrollbar-color: #6c757d #f8f9fa;
            }
            
            .table-responsive-custom::-webkit-scrollbar {
                width: 12px;
                height: 12px;
            }
            
            .table-responsive-custom::-webkit-scrollbar-track {
                background: #f8f9fa;
                border-radius: 6px;
            }
            
            .table-responsive-custom::-webkit-scrollbar-thumb {
                background: #6c757d;
                border-radius: 6px;
                border: 2px solid #f8f9fa;
            }
            
            .table-responsive-custom::-webkit-scrollbar-thumb:hover {
                background: #495057;
            }
            
            .table-responsive-custom::-webkit-scrollbar-corner {
                background: #f8f9fa;
            }
            
            /* Hacer que el header se mantenga fijo al hacer scroll vertical */
            .sticky-top {
                position: sticky;
                top: 0;
                z-index: 10;
            }
            
            /* Mejorar la visualización de celdas con contenido largo */
            .table-responsive-custom td {
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                max-width: 250px;
            }
            
            /* Permitir que las celdas de coordenadas muestren más contenido */
            .table-responsive-custom td[title] {
                cursor: help;
            }
            
            /* Indicador visual para scroll horizontal */
            .scroll-indicator {
                position: absolute;
                top: 50%;
                right: 10px;
                transform: translateY(-50%);
                background: rgba(108, 117, 125, 0.8);
                color: white;
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 12px;
                pointer-events: none;
                opacity: 0;
                transition: opacity 0.3s;
            }
            
            .table-responsive-custom:hover .scroll-indicator {
                opacity: 1;
            }
        </style>
        
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                const tableContainer = document.querySelector('.table-responsive-custom');
                const scrollIndicator = document.querySelector('.scroll-indicator');
                
                if (tableContainer && scrollIndicator) {
                    // Función para actualizar el indicador de scroll
                    function updateScrollIndicator() {
                        const scrollLeft = tableContainer.scrollLeft;
                        const scrollWidth = tableContainer.scrollWidth;
                        const clientWidth = tableContainer.clientWidth;
                        const maxScroll = scrollWidth - clientWidth;
                        
                        if (maxScroll > 0) {
                            const scrollPercentage = (scrollLeft / maxScroll) * 100;
                            
                            if (scrollPercentage === 0) {
                                scrollIndicator.textContent = '→ Desplazar a la derecha';
                                scrollIndicator.style.opacity = '1';
                            } else if (scrollPercentage >= 99) {
                                scrollIndicator.textContent = '← Desplazar a la izquierda';
                                scrollIndicator.style.opacity = '1';
                            } else {
                                scrollIndicator.textContent = `← → ${Math.round(scrollPercentage)}%`;
                                scrollIndicator.style.opacity = '0.7';
                            }
                        } else {
                            scrollIndicator.style.opacity = '0';
                        }
                    }
                    
                    // Actualizar indicador al hacer scroll
                    tableContainer.addEventListener('scroll', updateScrollIndicator);
                    
                    // Actualizar indicador al cargar
                    setTimeout(updateScrollIndicator, 100);
                    
                    // Actualizar indicador al redimensionar ventana
                    window.addEventListener('resize', updateScrollIndicator);
                    
                    // Mostrar/ocultar indicador al hacer hover
                    tableContainer.addEventListener('mouseenter', function() {
                        if (tableContainer.scrollWidth > tableContainer.clientWidth) {
                            scrollIndicator.style.opacity = '1';
                        }
                    });
                    
                    tableContainer.addEventListener('mouseleave', function() {
                        setTimeout(function() {
                            if (tableContainer.scrollLeft === 0 || 
                                tableContainer.scrollLeft >= (tableContainer.scrollWidth - tableContainer.clientWidth - 1)) {
                                scrollIndicator.style.opacity = '0.5';
                            } else {
                                scrollIndicator.style.opacity = '0';
                            }
                        }, 1000);
                    });
                }
            });
        </script>
        
        <div class="card">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center mb-4">
                    <h3 class="mb-0">Datos del archivo: {{ filename }}</h3>
                    <div class="d-flex align-items-center gap-2">
                        <span class="badge bg-primary">{{ data|length }} registros</span>
                        <small class="text-muted">
                            <i class="bi bi-arrow-left-right"></i> Desplazarse horizontalmente para ver todas las columnas
                        </small>
                    </div>
                </div>
                
                {% if data and columns %}
                <div class="position-relative">
                    <div class="scroll-indicator">← → Desplazar horizontalmente</div>
                    <div class="table-responsive-custom" style="max-height: 600px; overflow-x: auto; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 0.375rem;">
                    <table class="table table-hover table-striped mb-0" style="min-width: 1200px;">
                        <thead class="table-light sticky-top">
                            <tr>
                                <th style="min-width: 50px;">#</th>
                                {% for col in columns %}
                                    {# Highlight specific columns for clarity #}
                                    {% if col in ['COORDENADAS', 'COORDENADAS_CORREGIDAS'] %}
                                        <th class="bg-info text-white" style="min-width: 200px; max-width: 250px;">{{ col }}</th>
                                    {% elif col == 'AREA_DIGITALIZADA' %}
                                        <th class="bg-success text-white" style="min-width: 120px;">{{ col }} (ha)</th>
                                    {% elif col in ['ESTADO', 'MUNICIPIO', 'ESTATUS'] %}
                                        <th class="bg-light" style="min-width: 100px;">{{ col }}</th> {# Newly added columns #}
                                    {% elif col == 'COMENTARIOS' %}
                                        <th class="bg-light" style="min-width: 150px;">{{ col }}</th> {# Comentarios column #}
                                    {% elif col == 'DESCRIPCION' %}
                                        <th class="bg-light" style="min-width: 150px;">{{ col }}</th> {# Descripcion column #}
                                    {% else %}
                                        <th style="min-width: 100px;">{{ col }}</th>
                                    {% endif %}
                                {% endfor %}
                                <th style="min-width: 80px;">Acciones</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for row in data %}
                            <tr>
                                <td>{{ loop.index }}</td>
                                {% for col in columns %}
                                    {% if col in ['COORDENADAS', 'COORDENADAS_CORREGIDAS'] %}
                                        <td style="max-width: 150px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="{{ row[col] if row[col] is not none else '' }}">
                                    {% else %}
                                        <td>
                                    {% endif %}
                                        {# Display values, handle None #}
                                        {% if row[col] is not none and row[col] != '' %}
                                            {% if col == 'AREA_DIGITALIZADA' %}
                                                {{ "%.2f"|format(row[col]|float) }} ha
                                            {% else %}
                                                {{ row[col] }}
                                            {% endif %}
                                        {% else %}
                                            <span class="text-muted">--</span> {# Display dashes for empty values #}
                                        {% endif %}
                                    </td>
                                {% endfor %}
                                <td>
                                    {# Link to edit page using db_id #}
                                    {% if row.get('db_id') %}
                                    <a href="{{ url_for('validacion_poligonos', tab='editar', db_id=row.db_id) }}" title="Editar Polígono">
                                        <i class="bi bi-geo-alt" style="font-size: 1.2rem; cursor: pointer;"></i>
                                    </a>
                                    {% else %}
                                    <span title="Registro no guardado en DB"></span> {# Indicate if not in DB #}
                                    {% endif %}
                                </td>
                            </tr>
                            {% endfor %}
                        </tbody>
                        
                    </table>
                    </div>
                </div>
                {% else %}
                <div class="alert alert-warning">
                    No hay datos disponibles.
                </div>
                {% endif %}
            </div>
        </div>


        {% elif tab == 'editar' %}
        <!-- Pestaña de Editar Polígono -->
        <div class="card">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center mb-4">
                    <h3 class="mb-0">Editar Polígono: polygon-{{ row_index if row_index is defined else '0' }}</h3>
                    <div class="badge bg-info" id="registro-info">
                        {% if db_id is defined %}
                            Registro ID: {{ db_id }}
                        {% elif row_index is defined %}
                            Registro: {{ row_index + 1 }}
                        {% endif %}
                    </div>
                </div>
                
                {% if poligono_data %}
                <form action="{{ url_for('actualizar_fila') }}" method="post" id="formEditarPoligono">
                    {% if db_id is defined %}
                    <input type="hidden" name="db_id" value="{{ db_id }}">
                    {% else %}
                    <input type="hidden" name="row_index" value="{{ row_index }}">
                    {% endif %}
                    
                    <div class="row">
                        <div class="col-md-6">
                            <div class="row mb-3">
                                <div class="col-md-6">
                                    <label for="Area_reportada" class="form-label">Área Reportada</label>
                                    <input type="text" class="form-control" id="Area_reportada" name="SUPERFICIE" 
                                           value="{{ poligono_data.get('SUPERFICIE', '0') }}">
                                </div>
                                <div class="col-md-6">
                                    <label for="Area_digitalizada" class="form-label">Área Digitalizada (ha)</label>
                                    <input type="text" class="form-control" id="Area_digitalizada" name="AREA_DIGITALIZADA" 
                                           pattern="[0-9]+(\.[0-9]+)?" title="Ingrese un número válido (ej: 123.456)" 
                                           value="{{ poligono_data.get('AREA_DIGITALIZADA', '0.0') }}">
                                    <small class="text-muted">Calculada geodésicamente</small>
                                </div>
                            </div>
                            
                            <div class="row mb-3">
                                <div class="col-md-6">
                                    <label for="Estado" class="form-label">Estado</label>
                                    <div class="input-group">
                                        <input type="text" class="form-control" id="Estado" name="ESTADO" 
                                            value="{{ poligono_data.get('ESTADO', '') }}">
                                        {% if poligono_data.get('UBICACION_AUTO') %}
                                        <span class="input-group-text" title="Detectado automáticamente"><i class="bi bi-geo-alt-fill text-success"></i></span>
                                        {% endif %}
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <label for="Municipio" class="form-label">Municipio</label>
                                    <div class="input-group">
                                        <input type="text" class="form-control" id="Municipio" name="MUNICIPIO" 
                                            value="{{ poligono_data.get('MUNICIPIO', '') }}">
                                        {% if poligono_data.get('UBICACION_AUTO') %}
                                        <span class="input-group-text" title="Detectado automáticamente"><i class="bi bi-geo-alt-fill text-success"></i></span>
                                        {% endif %}
                                    </div>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label for="COORDENADAS_DECIMALES_CORREGIDAS" class="form-label">Coordenadas (Formato decimal)</label>
                                <textarea class="form-control" id="COORDENADAS_DECIMALES_CORREGIDAS" name="COORDENADAS_DECIMALES_CORREGIDAS" 
                                          rows="3">{{ poligono_data.get('COORDENADAS_DECIMALES_CORREGIDAS', '') }}</textarea>
                                <small class="text-muted">Formato: latitud,longitud | latitud,longitud | ...</small>
                            </div>
                            
                            <div class="row mb-3">
                                <div class="col-12">
                                    <label for="ComentariosSelect" class="form-label">Comentarios</label>
                                    <select class="form-select mb-2" id="ComentariosSelect">
                                        <option value="">-- Seleccionar comentario predefinido --</option>
                                        <option value="CUMPLE CON LA SUPERFICIE">CUMPLE CON LA SUPERFICIE</option>
                                        <option value="NO CUMPLE CON LA SUPERFICIE">NO CUMPLE CON LA SUPERFICIE</option>
                                        <option value="NO COINCIDE LA SUPERFICIE">NO COINCIDE LA SUPERFICIE</option>
                                        <option value="NO SE PUEDE DIGITALIZAR">NO SE PUEDE DIGITALIZAR</option>
                                        <option value="SE ENCUENTRA EN HISTORICO">SE ENCUENTRA EN HISTORICO</option>
                                    </select>
                                    <textarea class="form-control" id="Comentarios" name="COMENTARIOS" rows="2">{{ poligono_data.get('COMENTARIOS', '') if poligono_data.get('COMENTARIOS') != None else '' }}</textarea>
                                </div>
                            </div>
                            
                            <div class="row mb-3">
                                <div class="col-12">
                                    <label for="DescripcionSelect" class="form-label">Descripción</label>
                                    <select class="form-select mb-2" id="DescripcionSelect">
                                        <option value="">-- Seleccionar tipo de descripción --</option>
                                        <option value="PARCELA CON CAMINO = C">PARCELA CON CAMINO = C</option>
                                        <option value="PARCELA CON CAMINOS = CC">PARCELA CON CAMINOS = CC</option>
                                        <option value="PARCELA CON CANAL = X">PARCELA CON CANAL = X</option>
                                        <option value="PARCELA CON CANALES = XX">PARCELA CON CANALES = XX</option>
                                        <option value="PARCELA CON SUPERFICIE NO AGRICOLA = A">PARCELA CON SUPERFICIE NO AGRICOLA = A</option>
                                        <option value="PARCELA CON EDIFICACIONES = E">PARCELA CON EDIFICACIONES = E</option>
                                        <option value="INFRAESTRUCTURA DE INVERNADEROS Y MACROTUNELES = M">INFRAESTRUCTURA DE INVERNADEROS Y MACROTUNELES = M</option>
                                        <option value="FRACCION DE PARCELA = F">FRACCION DE PARCELA = F</option>
                                        <option value="LA PARCELA CONTIENE A, ID POLIGONO" data-requires-id="true">LA PARCELA CONTIENE A, ID POLIGONO</option>
                                        <option value="PARCELA CONTENIDA POR, ID POLIGONO" data-requires-id="true">PARCELA CONTENIDA POR, ID POLIGONO</option>
                                        <option value="PARCELA TRASLAPADA CON, ID POLIGONO" data-requires-id="true">PARCELA TRASLAPADA CON, ID POLIGONO</option>
                                        <option value="LA PARCELA IGUAL A, ID POLIGONO" data-requires-id="true">LA PARCELA IGUAL A, ID POLIGONO</option>
                                    </select>
                                    <select class="form-select mb-2" id="DescripcionIdSelect" style="display: none;">
                                        <option value="">-- Seleccionar ID de polígono --</option>
                                        <!-- Opciones de IDs históricos y actuales se cargarán dinámicamente -->
                                    </select>
                                    <textarea class="form-control" id="Descripcion" name="DESCRIPCION" rows="2">{{ poligono_data.get('DESCRIPCION', '') if poligono_data.get('DESCRIPCION') != None else '' }}</textarea>
                                </div>
                            </div>
                            
                            <div class="row mb-3">
                                <div class="col-12">
                                    <label for="Orden" class="form-label">Orden</label>
                                    <textarea class="form-control" id="Orden" name="ORDEN" rows="2">{{ poligono_data.get('ORDEN', '') if poligono_data.get('ORDEN') != None else '' }}</textarea>
                                    <small class="text-muted">Se llena automáticamente cuando se selecciona un ID de polígono en la descripción</small>
                                </div>
                            </div>
                            
                            <div class="row mb-3">
                                <div class="col-12">
                                    <label class="form-label">Estatus</label>
                                    <div class="form-check">
                                        <input class="form-check-input" type="radio" name="ESTATUS" id="Estatus6" value="6" {% if poligono_data.get('ESTATUS') == '6' or poligono_data.get('ESTATUS') == 6 %}checked{% endif %}>
                                        <label class="form-check-label" for="Estatus6">
                                            Estatus 6
                                        </label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="radio" name="ESTATUS" id="Estatus7" value="7" {% if poligono_data.get('ESTATUS') == '7' or poligono_data.get('ESTATUS') == 7 %}checked{% endif %}>
                                        <label class="form-check-label" for="Estatus7">
                                            Estatus 7
                                        </label>
                                    </div>
                                    <small class="text-muted">Nota: Estatus 7 se selecciona automáticamente si la diferencia entre áreas es ≤11%</small>
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <button type="button" id="btnDetectarUbicacion" class="btn btn-outline-primary btn-sm">
                                    <i class="bi bi-geo-alt"></i> Detectar Municipio/Estado
                                </button>
                                <small id="infoUbicacion" class="text-muted ms-2"></small>
                            </div>
                            
                            <!-- Sección para información de polígonos históricos -->
                            <div class="mb-3 alert alert-warning">
                                <h5><i class="bi bi-exclamation-triangle-fill"></i> Verificación de traslapes</h5>
                                <p>Se están mostrando polígonos en el mapa para verificar traslapes:</p>
                                <ul>
                                    <li><strong style="color: #ff8c00;">Polígonos históricos</strong> en color <strong style="color: #ff8c00;">naranja</strong> (línea sólida)</li>
                                    <li><strong style="color: #d63031;">Polígonos del archivo actual</strong> en color <strong style="color: #d63031;">rojo punteado</strong></li>
                                </ul>
                                <p>Por favor, verifique si el polígono actual traslapa con alguno de estos polígonos y documente los resultados en los comentarios.</p>
                                <div id="historico-info" class="mt-2">
                                    <small>Para las descripciones que requieren un ID de polígono, se habilitará un selector adicional con los IDs disponibles. Los IDs con el prefijo <strong>"Histórico:"</strong> corresponden a polígonos del shapefile histórico, y los IDs con prefijo <strong>"Actual:"</strong> corresponden a polígonos del archivo actual.</small>
                                </div>
                            </div>
                            
                            <div class="mt-4 d-flex">
                                <button type="button" id="btnCancelar" class="btn btn-outline-secondary me-2">
                                    <i class="bi bi-x"></i> Cancelar
                                </button>
                                <button type="submit" class="btn btn-primary me-2">
                                    <i class="bi bi-save"></i> Guardar Cambios
                                </button>
                                <button type="button" id="btnGuardarSiguiente" class="btn btn-success">
                                    <i class="bi bi-save"></i><i class="bi bi-arrow-right ms-1"></i> Guardar y Siguiente
                                </button>
                            </div>
                        </div>
                        
                        <div class="col-md-6">
                            <div id="map" style="height: 550px; width: 100%; border-radius: 4px;"></div>
                            
                            <!-- Controles de Visibilidad de Capas -->
                            <div class="mt-3">
                                <div class="card">
                                    <div class="card-header py-2">
                                        <h6 class="mb-0"><i class="bi bi-layers"></i> Control de Capas</h6>
                                    </div>
                                    <div class="card-body py-2">
                                        <div class="row">
                                            <div class="col-md-6">
                                                <div class="form-check form-switch mb-2">
                                                    <input class="form-check-input" type="checkbox" id="toggleHistoricos" checked>
                                                    <label class="form-check-label" for="toggleHistoricos">
                                                        <span style="color: #ff8c00; font-weight: bold;">●</span> Polígonos Históricos
                                                    </label>
                                                </div>
                                                <div class="form-check form-switch mb-2">
                                                    <input class="form-check-input" type="checkbox" id="toggleActuales" checked>
                                                    <label class="form-check-label" for="toggleActuales">
                                                        <span style="color: #d63031; font-weight: bold;">●</span> Polígonos Actuales
                                                    </label>
                                                </div>
                                            </div>
                                            <div class="col-md-6">
                                                <div class="form-check form-switch mb-2">
                                                    <input class="form-check-input" type="checkbox" id="togglePoligonoActual" checked>
                                                    <label class="form-check-label" for="togglePoligonoActual">
                                                        <span style="color: #0066cc; font-weight: bold;">●</span> Polígono Actual
                                                    </label>
                                                </div>
                                                <button type="button" class="btn btn-outline-primary btn-sm" id="zoomToPoligono">
                                                    <i class="bi bi-zoom-in"></i> Zoom al Polígono
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </form>
                {% else %}
                <div class="alert alert-danger">
                    No se encontró el registro solicitado.
                </div>
                <a href="{{ url_for('validacion_poligonos', tab='lista') }}" class="btn btn-outline-primary">
                    Volver a la lista
                </a>
                {% endif %}
            </div>
        </div>
        
        <!-- Scripts para Leaflet -->
        <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
        
        <!-- Leaflet.draw para edición de polígonos -->
        <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" crossorigin=""/>
        <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js" crossorigin=""></script>
        
        <!-- Leaflet.GeometryUtil para calcular áreas -->
        <script src="https://unpkg.com/leaflet-geometryutil@0.10.1/src/leaflet.geometryutil.js" crossorigin=""></script>
        
        <!-- Leaflet.fullscreen plugin -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet.fullscreen@2.4.0/Control.FullScreen.css" />
        <script src="https://cdn.jsdelivr.net/npm/leaflet.fullscreen@2.4.0/Control.FullScreen.js"></script>
        
        <!-- Turf.js para operaciones geométricas -->
        <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
        
        <style>
            .edit-control-container {
                margin-bottom: 5px;
            }
            .editing-mode-indicator {
                position: absolute;
                top: 10px;
                left: 50px;
                z-index: 1000;
                background-color: rgba(255, 255, 255, 0.8);
                padding: 5px 10px;
                border-radius: 4px;
                box-shadow: 0 1px 5px rgba(0,0,0,0.4);
                display: none;
                font-weight: bold;
                color: #ff4500;
            }
            /* Estilos para el botón de pantalla completa */
            .leaflet-control-fullscreen a {
                background-color: #fff;
                border-radius: 4px;
                box-shadow: 0 1px 5px rgba(0,0,0,0.4);
                transition: all 0.3s ease;
            }
            .leaflet-control-fullscreen a:hover {
                background-color: #f4f4f4;
                transform: scale(1.05);
            }
            .fullscreen-icon {
                background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJmZWF0aGVyIGZlYXRoZXItbWF4aW1pemUiPjxwYXRoIGQ9Ik04IDN2M2EyIDIgMCAwIDEtMiAySDNtMTggMGgtM2EyIDIgMCAwIDEtMi0yVjNtMCAxOHYtM2EyIDIgMCAwIDEgMi0yaDNNMyAxNmgzYTIgMiAwIDAgMSAyIDJ2MyI+PC9wYXRoPjwvc3ZnPg==);
            }
            /* Fin estilos pantalla completa */
            
            /* Estilos para tooltips personalizados */
            .custom-tooltip {
                background-color: rgba(255, 140, 0, 0.9) !important;
                border: 1px solid #ff8c00 !important;
                border-radius: 4px !important;
                color: white !important;
                font-size: 12px !important;
                padding: 6px 8px !important;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3) !important;
            }
            
            .custom-tooltip-actual {
                background-color: rgba(214, 48, 49, 0.9) !important;
                border: 1px solid #d63031 !important;
                border-radius: 4px !important;
                color: white !important;
                font-size: 12px !important;
                padding: 6px 8px !important;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3) !important;
            }
            
            .custom-tooltip::before,
            .custom-tooltip-actual::before {
                border-color: transparent !important;
            }
            
            .custom-leaflet-btn {
                margin-bottom: 5px;
                display: block;
            }
            .custom-leaflet-btn button {
                width: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 6px 10px;
                font-weight: 500;
                box-shadow: 0 1px 5px rgba(0,0,0,0.4);
            }
            .custom-leaflet-btn button i {
                margin-right: 5px;
            }
            .edit-instructions {
                position: absolute;
                bottom: 20px;
                left: 10px;
                z-index: 1000;
                background-color: rgba(255, 255, 255, 0.9);
                padding: 10px;
                border-radius: 4px;
                box-shadow: 0 1px 5px rgba(0,0,0,0.4);
                max-width: 300px;
                font-size: 12px;
                display: none;
            }
            .edit-instructions h5 {
                margin-top: 0;
                font-size: 14px;
                font-weight: bold;
            }
            .edit-instructions ul {
                padding-left: 20px;
                margin-bottom: 0;
            }
            .vertex-marker {
                cursor: move;
            }
            .vertex-marker div {
                transition: background-color 0.2s, border-color 0.2s, transform 0.2s;
            }
            .vertex-marker div:hover {
                background-color: #ff4500;
                border-color: white;
                transform: scale(1.2);
            }
            /* Ocultar los controles de edición nativos de Leaflet.Draw */
            .leaflet-draw-toolbar {
                display: none !important;
            }
            .leaflet-draw-edit-edit, .leaflet-draw-edit-remove {
                display: none !important;
            }
            .leaflet-draw {
                display: none !important;
            }
        </style>
        
        <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Inicialización global de variables de control
            window.editingMode = false;
            window.drawingMode = false;
            
            // Código para el dropdown de comentarios predefinidos
            const comentariosSelect = document.getElementById('ComentariosSelect');
            const comentariosTextarea = document.getElementById('Comentarios');
            
            if (comentariosSelect && comentariosTextarea) {
                comentariosSelect.addEventListener('change', function() {
                    if (this.value) {
                        // Si el textarea ya tiene contenido, añadir una nueva línea
                        if (comentariosTextarea.value && comentariosTextarea.value.trim() !== '') {
                            comentariosTextarea.value += '\n' + this.value;
                        } else {
                            comentariosTextarea.value = this.value;
                        }
                    }
                    // Resetear el select
                    this.selectedIndex = 0;
                });
            }
            
            // Código para el dropdown de tipos de descripción
            const descripcionSelect = document.getElementById('DescripcionSelect');
            const descripcionIdSelect = document.getElementById('DescripcionIdSelect');
            const descripcionTextarea = document.getElementById('Descripcion');
            
            if (descripcionSelect && descripcionTextarea) {
                descripcionSelect.addEventListener('change', function() {
                    const selectedOption = this.options[this.selectedIndex];
                    const requiresId = selectedOption.getAttribute('data-requires-id') === 'true';
                    
                    if (requiresId) {
                        // Mostrar el dropdown de IDs si la opción requiere ID
                        descripcionIdSelect.style.display = 'block';
                    } else {
                        // Ocultar el dropdown de IDs y añadir el valor directamente
                        descripcionIdSelect.style.display = 'none';
                        if (this.value) {
                            // Si el textarea ya tiene contenido, añadir una nueva línea
                            if (descripcionTextarea.value && descripcionTextarea.value.trim() !== '') {
                                descripcionTextarea.value += '\n' + this.value;
                            } else {
                                descripcionTextarea.value = this.value;
                            }
                        }
                        // Resetear el select
                        this.selectedIndex = 0;
                    }
                });
            }
            
            // Código para el dropdown de IDs de polígonos
            if (descripcionIdSelect && descripcionTextarea) {
                descripcionIdSelect.addEventListener('change', function() {
                    if (this.value && descripcionSelect.value) {
                        // Reemplazar "ID POLIGONO" en la descripción seleccionada con el ID específico
                        const descripcionBase = descripcionSelect.value;
                        const descripcionCompleta = descripcionBase.replace('ID POLIGONO', this.value);
                        
                        // Si el textarea ya tiene contenido, añadir una nueva línea
                        if (descripcionTextarea.value && descripcionTextarea.value.trim() !== '') {
                            descripcionTextarea.value += '\n' + descripcionCompleta;
                        } else {
                            descripcionTextarea.value = descripcionCompleta;
                        }
                        
                        // Obtener el número de orden del atributo data-orden
                        const selectedOption = this.options[this.selectedIndex];
                        const orden = selectedOption.getAttribute('data-orden');
                        const ordenTextarea = document.getElementById('Orden');
                        
                        if (orden && orden.trim() !== '' && ordenTextarea) {
                            // Si el textarea de orden ya tiene contenido, añadir una nueva línea
                            if (ordenTextarea.value && ordenTextarea.value.trim() !== '') {
                                ordenTextarea.value += '\n' + orden;
                            } else {
                                ordenTextarea.value = orden;
                            }
                        }
                        
                        // Resetear ambos selects y ocultar el dropdown de IDs
                        descripcionSelect.selectedIndex = 0;
                        this.selectedIndex = 0;
                        this.style.display = 'none';
                    }
                });
            }
            
            // Verificar que Leaflet está disponible
            if (typeof L === 'undefined') {
                console.error("Leaflet no está disponible. Intentando cargar nuevamente...");
                
                // Insertar scripts dinámicamente
                var leafletCSS = document.createElement('link');
                leafletCSS.rel = 'stylesheet';
                leafletCSS.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
                document.head.appendChild(leafletCSS);
                
                var leafletScript = document.createElement('script');
                leafletScript.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
                leafletScript.onload = function() {
                    console.log("Leaflet cargado dinámicamente, reiniciando mapa...");
                    initializeMap();
                };
                document.head.appendChild(leafletScript);
                
                // Mensaje al usuario
                var mapDiv = document.getElementById('map');
                if (mapDiv) {
                    mapDiv.innerHTML = "<div class='alert alert-warning'>Cargando mapa, por favor espere...</div>";
                }
                
                return; // Salir de la función actual, esperamos a que se cargue Leaflet
            }
            
            // Si Leaflet está disponible, inicializar el mapa
            console.log("Iniciando mapa con Leaflet disponible");
            initializeMap();
        });
        
        function initializeMap() {
            // Indicador para saber si estamos en modo de edición
            var editingInProgress = false;
            
            console.log("Iniciando configuración del mapa...");
            
            // Verificación HTML del div del mapa
            var mapElement = document.getElementById('map');
            
            if (!mapElement) {
                console.error("Elemento #map no encontrado en el DOM!");
                return;
            }
            
            // Asegurar que el elemento del mapa es visible
            mapElement.style.height = '550px';
            mapElement.style.width = '100%';
            mapElement.style.display = 'block';
            mapElement.style.backgroundColor = '#f0f0f0';
            mapElement.innerHTML = '';
            
            // Probar con una fuente alternativa de mapas (inicialización más sencilla)
            try {
                console.log("Creando mapa...");
                var map = L.map('map', {
                    center: [25.6866, -100.3161], // Centro en Monterrey por defecto
                    zoom: 5,
                    maxZoom: 18,
                    fullscreenControl: true,
                    fullscreenControlOptions: {
                        position: 'topleft',
                        title: 'Pantalla Completa',
                        titleCancel: 'Salir de Pantalla Completa'
                    }
                });
                
                // Añadir diferentes capas base como opciones
                var baseLayers = {
                    "OpenStreetMap": L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
                        maxZoom: 19
                    }),
                    "Esri World Imagery": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                        attribution: 'Tiles &copy; Esri &mdash; Source: Esri',
                        maxZoom: 18
                    }),
                    "CartoDB Dark": L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>, &copy; <a href="https://carto.com/attributions">CARTO</a>',
                        maxZoom: 19
                    })
                };
                
                // Añadir la primera capa base por defecto
                baseLayers["Esri World Imagery"].addTo(map);
                
                // Añadir control de capas para cambiar entre fondos de mapa
                L.control.layers(baseLayers, {}).addTo(map);
                
                console.log("Mapa creado correctamente");
            } catch (e) {
                console.error("Error al crear el mapa:", e);
                
                // Mostrar mensaje de error en el elemento del mapa
                mapElement.innerHTML = "<div class='alert alert-danger'>Error al cargar el mapa: " + e.message + "</div>";
                
                // Intentar alternativamente con un iframe de Google Maps
                try {
                    console.log("Intentando alternativa con iframe de Google Maps...");
                    // Obtener coordenadas para centro aproximado
                    var coordText = document.getElementById('COORDENADAS_DECIMALES_CORREGIDAS').value;
                    var center = "24.6866,-99.3161"; // México por defecto
                    
                    if (coordText && coordText.trim() !== '') {
                        var firstCoord = coordText.split('|')[0].trim();
                        if (firstCoord.includes(',')) {
                            center = firstCoord;
                        }
                    }
                    
                    // Crear iframe con Google Maps
                    mapElement.innerHTML = '<div style="position: relative; width: 100%; height: 550px;">' +
                        '<iframe width="100%" height="550" frameborder="0" style="border:0" src="https://www.google.com/maps/embed/v1/view?key=YOUR_API_KEY&center=' + center + '&zoom=10" allowfullscreen></iframe>' +
                        '<button id="googleMapsFullscreen" style="position: absolute; top: 10px; left: 10px; z-index: 1000; background-color: white; border: 2px solid rgba(0,0,0,0.2); border-radius: 4px; padding: 5px 10px; cursor: pointer;"><i class="bi bi-arrows-fullscreen"></i> Pantalla Completa</button>' +
                        '</div>';
                    
                    // Añadir evento al botón de pantalla completa para Google Maps
                    setTimeout(function() {
                        var fullscreenButton = document.getElementById('googleMapsFullscreen');
                        if (fullscreenButton) {
                            fullscreenButton.addEventListener('click', function() {
                                var iframeContainer = fullscreenButton.parentElement;
                                if (iframeContainer) {
                                    if (document.fullscreenElement) {
                                        document.exitFullscreen();
                                    } else {
                                        iframeContainer.requestFullscreen();
                                    }
                                }
                            });
                        }
                    }, 100);
                    
                    // Mensaje al usuario
                    mapElement.innerHTML += "<div class='alert alert-warning mt-2'>Se está mostrando un mapa alternativo. La edición no está disponible.</div>";
                    
                    // Deshabilitar botones relacionados con el mapa
                    var mapButtons = document.querySelectorAll('#editPolygon, #savePolygonChanges, #cancelPolygonChanges');
                    mapButtons.forEach(function(btn) {
                        if (btn) btn.disabled = true;
                    });
                    
                    return;
                } catch (iframeErr) {
                    console.error("También falló el iframe:", iframeErr);
                }
                
                return;
            }
            
            // Crear grupo de edición
            var editableLayers = new L.FeatureGroup();
            map.addLayer(editableLayers);
            
            // Variables globales para capas de polígonos
            var historicoLayerGroup = new L.LayerGroup();
            var actualesLayerGroup = new L.LayerGroup();
            var poligonoActualLayer = editableLayers; // El polígono actual está en editableLayers
            
            // Agregar capas al mapa
            map.addLayer(historicoLayerGroup);
            map.addLayer(actualesLayerGroup);
            
            // Variables para guardar el polígono
            var polygon;
            var originalCoords = [];
            // Usar la variable global editingMode en lugar de declarar una local
            if (typeof window.editingMode === 'undefined') {
                window.editingMode = false;
            }
            if (typeof window.drawingMode === 'undefined') {
                window.drawingMode = false;
            }
            if (typeof window.addVertexMode === 'undefined') {
                window.addVertexMode = false;
            }
            
            // Configurar opciones de edición pero NO inicializar el control
            var drawOptions = {
                draw: false, // Desactivar todas las opciones de dibujo
                edit: {
                    featureGroup: editableLayers,
                    poly: {
                        allowIntersection: false
                    },
                    edit: {
                        selectedPathOptions: {
                            maintainColor: true,
                            opacity: 0.6,
                            fillOpacity: 0.3
                        }
                    },
                    remove: false
                }
            };
            
            // Inicializar variables
            var coordenadas = [];
            
            // Cargar coordenadas desde el backend (if present)
            {% if coords_para_mapa %}
            var coordenadas = {{ coords_para_mapa|tojson }};
            console.log("Coordenadas cargadas desde el backend:", coordenadas);
            {% else %}
            var coordenadas = [];
            console.log("No hay coordenadas disponibles desde el backend");
            {% endif %}
            
            // Crear polígono si hay suficientes coordenadas
            if (coordenadas && coordenadas.length >= 3) {
                try {
                    console.log("Creando polígono con coordenadas:", coordenadas);
                    
                    // Guardar copia de las coordenadas originales
                    originalCoords = JSON.parse(JSON.stringify(coordenadas));
                    
                    // Crear el polígono y añadirlo a la capa editable
                    polygon = L.polygon(coordenadas, {
                        color: '#0066cc', 
                        weight: 3, 
                        fillOpacity: 0.2,
                        pane: 'overlayPane',
                        interactive: true
                    });
                    editableLayers.addLayer(polygon);
                    
                    // Asegurar que el polígono actual esté siempre por encima de los históricos
                    if (polygon._path) {
                        polygon.bringToFront();
                    }
                    
                    // Ajustar el mapa para mostrar todo el polígono
                    try {
                        console.log("Ajustando vista al polígono");
                        map.fitBounds(polygon.getBounds());
                    } catch (e) {
                        console.error("Error al ajustar vista:", e);
                        // Fallback: centrar en la primera coordenada
                        map.setView(coordenadas[0], 12);
                    }
                    
                    // Calcular y mostrar el área inicialmente
                    try {
                        var areaSqMeters = L.GeometryUtil.geodesicArea(polygon.getLatLngs()[0]);
                        var areaHectares = areaSqMeters / 10000; // Convertir a hectáreas
                        document.getElementById('Area_digitalizada').value = areaHectares.toFixed(4);
                        console.log("Área calculada:", areaHectares.toFixed(4), "hectáreas");
                        // Calcular estatus automáticamente
                        if (typeof calcularEstatus === 'function') calcularEstatus();
                    } catch (e) {
                        console.error("Error al calcular área:", e);
                    }
                    
                    // Cargar polígonos históricos para verificar traslapes
                    {% if db_id %}
                    // Si hay un ID de base de datos, cargar solo polígonos en un radio de 5km
                    cargarPoligonosHistoricos(map, {{ db_id }});
                    {% else %}
                    // Sin ID de base de datos, cargar todos (por compatibilidad con dibujo de polígono nuevo)
                    cargarPoligonosHistoricos(map);
                    {% endif %}
                } catch (error) {
                    console.error("Error al crear polígono:", error);
                }
            } else if (coordenadas.length === 2) {
                try {
                    console.log("Creando marcadores para las dos coordenadas:", coordenadas);
                    
                    // Guardar copia de las coordenadas originales
                    originalCoords = JSON.parse(JSON.stringify(coordenadas));
                    
                    // Crear marcador para el primer punto
                    var marker1 = L.marker(coordenadas[0], {
                        icon: L.divIcon({
                            className: 'two-point-marker',
                            html: '<div style="width: 14px; height: 14px; background-color: #0066cc; border: 2px solid white; border-radius: 50%; box-shadow: 0 0 4px rgba(0,0,0,0.5);"></div>',
                            iconSize: [14, 14],
                            iconAnchor: [7, 7]
                        })
                    });
                    
                    // Crear marcador para el segundo punto
                    var marker2 = L.marker(coordenadas[1], {
                        icon: L.divIcon({
                            className: 'two-point-marker',
                            html: '<div style="width: 14px; height: 14px; background-color: #0066cc; border: 2px solid white; border-radius: 50%; box-shadow: 0 0 4px rgba(0,0,0,0.5);"></div>',
                            iconSize: [14, 14],
                            iconAnchor: [7, 7]
                        })
                    });
                    
                    // Añadir popups informativos
                    marker1.bindPopup("Punto 1<br>Lat: " + coordenadas[0][0] + "<br>Lng: " + coordenadas[0][1]);
                    marker2.bindPopup("Punto 2<br>Lat: " + coordenadas[1][0] + "<br>Lng: " + coordenadas[1][1]);
                    
                    // Añadir marcadores a la capa editable
                    editableLayers.addLayer(marker1);
                    editableLayers.addLayer(marker2);
                    
                    // Dibujar una línea entre los dos puntos (opcional)
                    var linea = L.polyline([coordenadas[0], coordenadas[1]], {color: '#0066cc', weight: 2, dashArray: '5, 5'});
                    editableLayers.addLayer(linea);
                    
                    // Calcular el punto medio para centrar el mapa
                    var latMedio = (coordenadas[0][0] + coordenadas[1][0]) / 2;
                    var lngMedio = (coordenadas[0][1] + coordenadas[1][1]) / 2;
                    
                    // Crear bounds para abarcar ambos puntos
                    var bounds = L.latLngBounds([coordenadas[0], coordenadas[1]]);
                    map.fitBounds(bounds, {padding: [50, 50]});
                    
                    // Establecer área a 0 ya que son solo dos puntos
                    document.getElementById('Area_digitalizada').value = "0.0000";
                    
                    // Deshabilitar botón de edición de polígono ya que solo hay dos puntos
                    var editPolygonBtn = document.getElementById('editPolygon');
                    if (editPolygonBtn) {
                        editPolygonBtn.disabled = true;
                        editPolygonBtn.title = "No se puede editar con solo dos puntos";
                    }
                    
                    console.log("Marcadores creados y mapa ajustado a los dos puntos");
                } catch (error) {
                    console.error("Error al crear marcadores para las dos coordenadas:", error);
                }
            } else if (coordenadas.length === 1) {
                try {
                    console.log("Creando marcador para la coordenada única:", coordenadas[0]);
                    
                    // Guardar copia de la coordenada original
                    originalCoords = JSON.parse(JSON.stringify(coordenadas));
                    
                    // Crear marcador personalizado
                    var singleMarker = L.marker(coordenadas[0], {
                        icon: L.divIcon({
                            className: 'single-point-marker',
                            html: '<div style="width: 14px; height: 14px; background-color: #0066cc; border: 2px solid white; border-radius: 50%; box-shadow: 0 0 4px rgba(0,0,0,0.5);"></div>',
                            iconSize: [14, 14],
                            iconAnchor: [7, 7]
                        })
                    });
                    
                    // Añadir un popup informativo
                    singleMarker.bindPopup("Coordenada única<br>Lat: " + coordenadas[0][0] + "<br>Lng: " + coordenadas[0][1]);
                    
                    // Añadir marcador a la capa editable
                    editableLayers.addLayer(singleMarker);
                    
                    // Centrar mapa en el punto con un zoom apropiado
                    map.setView(coordenadas[0], 14);
                    
                    // Establecer área a 0 ya que es un punto
                    document.getElementById('Area_digitalizada').value = "0.0000";
                    
                    // Deshabilitar botón de edición de polígono ya que solo hay un punto
                    var editPolygonBtn = document.getElementById('editPolygon');
                    if (editPolygonBtn) {
                        editPolygonBtn.disabled = true;
                        editPolygonBtn.title = "No se puede editar un único punto";
                    }
                    
                    console.log("Marcador creado y mapa centrado en la coordenada única");
                } catch (error) {
                    console.error("Error al crear marcador para la coordenada única:", error);
                }
            } else {
                console.error("No se pudo crear el polígono o marcador: coordenadas insuficientes o inválidas");
                
                // Mostrar mensaje en el mapa
                var mapElement = document.getElementById('map');
                if (mapElement) {
                    var alertDiv = document.createElement('div');
                    alertDiv.className = 'alert alert-warning';
                    alertDiv.style.position = 'absolute';
                    alertDiv.style.top = '10px';
                    alertDiv.style.left = '10px';
                    alertDiv.style.zIndex = '1000';
                    alertDiv.style.padding = '10px';
                    alertDiv.style.borderRadius = '4px';
                    alertDiv.innerHTML = "No hay coordenadas válidas para mostrar. Por favor, ingrese al menos una coordenada.";
                    mapElement.appendChild(alertDiv);
                }
            }
            
            // NUEVO: Función para detectar ubicación del polígono
            function detectarUbicacionPoligono() {
                console.log("Detectando ubicación del polígono");
                var btnDetectar = document.getElementById('btnDetectarUbicacion');
                var infoUbicacion = document.getElementById('infoUbicacion');
                
                if (!polygon || polygon.getLatLngs().length === 0) {
                    infoUbicacion.textContent = 'No hay polígono definido';
                    infoUbicacion.style.color = 'red';
                    return;
                }
                
                // Obtener el centroide del polígono
                var centroid = turf.centroid(
                    turf.polygon([
                        polygon.getLatLngs()[0].map(p => [p.lng, p.lat])
                    ])
                );
                
                var lat = centroid.geometry.coordinates[1];
                var lon = centroid.geometry.coordinates[0];
                
                console.log("Centroide detectado:", lat, lon);
                infoUbicacion.textContent = 'Consultando ubicación...';
                infoUbicacion.style.color = 'blue';
                
                // Consultar ubicación via API
                fetch('/obtener_ubicacion', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({lat: lat, lon: lon})
                })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        document.getElementById('infoUbicacion').textContent = 'No se pudo determinar la ubicación';
                        document.getElementById('infoUbicacion').style.color = 'red';
                    } else {
                        // Actualizar los campos de Estado y Municipio
                        document.getElementById('Estado').value = data.estado;
                        document.getElementById('Municipio').value = data.municipio;
                        document.getElementById('infoUbicacion').textContent = 
                            `Ubicación detectada: ${data.municipio}, ${data.estado}`;
                        document.getElementById('infoUbicacion').style.color = 'green';
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    document.getElementById('infoUbicacion').textContent = 
                        'Error al consultar ubicación: ' + error.message;
                    document.getElementById('infoUbicacion').style.color = 'red';
                });
            }
            
            // Función para cargar polígonos históricos
            function cargarPoligonosHistoricos(map, polygon_id) {
                console.log("Cargando polígonos históricos...");
                
                // URL para la carga de polígonos históricos
                var url = '/get-historico-poligonos';
                
                // Si se proporciona un ID de polígono, usar la API de radio
                if (polygon_id) {
                    url = `/get-historico-poligonos-radio/${polygon_id}`;
                    console.log(`Cargando polígonos históricos en un radio de 5km alrededor del polígono ${polygon_id}...`);
                }
                
                fetch(url)
                    .then(response => response.json())
                    .then(data => {
                        if (data.error) {
                            console.error("Error al cargar polígonos históricos:", data.error);
                            return;
                        }
                        
                        var idField = data.id_field;
                        var ordenField = data.orden_field;
                        
                        // Eliminar capas históricas anteriores si existieran
                        historicoLayerGroup.clearLayers();
                        
                        // Para almacenar los IDs de los polígonos históricos
                        var historicalPolygonIds = [];
                        
                        // Crear nueva capa con los polígonos históricos
                        var historicoLayer = L.geoJSON(data.geojson, {
                            style: function (feature) {
                                return {
                                    color: "#ff8c00",  // Color naranja para históricos
                                    weight: 2,
                                    opacity: 0.8,
                                    fillOpacity: 0.3,
                                    pane: 'tilePane', // Usar un pane con menor prioridad
                                    interactive: true // Permitir interacción para tooltips
                                };
                            },
                            onEachFeature: function (feature, layer) {
                                // Determinar el ID del polígono si está disponible
                                var id = "";
                                var orden = "";
                                
                                if (idField && feature.properties && feature.properties[idField]) {
                                    id = feature.properties[idField];
                                }
                                
                                if (ordenField && feature.properties && feature.properties[ordenField]) {
                                    orden = feature.properties[ordenField];
                                }
                                
                                // Guardar el ID y orden para el dropdown
                                if (id) {
                                    historicalPolygonIds.push({
                                        id: id,
                                        orden: orden || ""
                                    });
                                }
                                
                                // Añadir tooltip con información del polígono
                                var tooltipContent = "";
                                if (id) {
                                    tooltipContent += `<b>ID: ${id}</b><br>`;
                                }
                                if (orden) {
                                    tooltipContent += `<b>Orden: ${orden}</b><br>`;
                                }
                                if (feature.properties) {
                                    for (var prop in feature.properties) {
                                        if (prop !== idField && prop !== ordenField && feature.properties[prop]) {
                                            tooltipContent += `${prop}: ${feature.properties[prop]}<br>`;
                                        }
                                    }
                                }
                                if (tooltipContent) {
                                    layer.bindTooltip(tooltipContent, {
                                        permanent: false,
                                        direction: 'auto',
                                        opacity: 0.9,
                                        className: 'custom-tooltip'
                                    });
                                }
                                
                                // Añadir efectos de hover para mejorar la experiencia
                                layer.on('mouseover', function(e) {
                                    var layer = e.target;
                                    layer.setStyle({
                                        weight: 3,
                                        opacity: 1,
                                        fillOpacity: 0.5
                                    });
                                    layer.bringToFront();
                                });
                                
                                layer.on('mouseout', function(e) {
                                    var layer = e.target;
                                    layer.setStyle({
                                        weight: 2,
                                        opacity: 0.8,
                                        fillOpacity: 0.3
                                    });
                                });
                            }
                        }).addTo(historicoLayerGroup);
                        
                        // Actualizar el dropdown de IDs históricos
                        var descripcionIdSelect = document.getElementById('DescripcionIdSelect');
                        if (descripcionIdSelect) {
                            // Limpiar opciones existentes excepto la primera (default)
                            while (descripcionIdSelect.options.length > 1) {
                                descripcionIdSelect.remove(1);
                            }
                            
                            // Añadir nuevas opciones con los IDs históricos
                            historicalPolygonIds.forEach(function(polygonInfo) {
                                var option = document.createElement('option');
                                // Si polygonInfo es un objeto con id y orden
                                if (typeof polygonInfo === 'object' && polygonInfo.id) {
                                    option.value = polygonInfo.id;
                                    option.textContent = "Histórico: " + polygonInfo.id;
                                    option.setAttribute('data-orden', polygonInfo.orden || '');
                                } else {
                                    // Compatibilidad con formato anterior (solo ID)
                                    option.value = polygonInfo;
                                    option.textContent = "Histórico: " + polygonInfo;
                                    option.setAttribute('data-orden', '');
                                }
                                descripcionIdSelect.appendChild(option);
                            });
                        }
                        
                        // Si se cargaron polígonos por radio, mostrar notificación
                        if (data.total !== undefined && polygon_id) {
                            // Crear un toast para informar cuántos polígonos se cargaron
                            var toastHTML = `
                            <div class="toast-container position-fixed bottom-0 end-0 p-3">
                              <div class="toast show" role="alert" aria-live="assertive" aria-atomic="true">
                                <div class="toast-header">
                                  <strong class="me-auto">Polígonos Históricos</strong>
                                  <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
                                </div>
                                <div class="toast-body">
                                  Se cargaron ${data.total} polígonos históricos en un radio de ${data.radio_km}km.
                                </div>
                              </div>
                            </div>`;
                            
                            var toastDiv = document.createElement('div');
                            toastDiv.innerHTML = toastHTML;
                            document.body.appendChild(toastDiv);
                            
                            // Eliminar el toast después de 5 segundos
                            setTimeout(function() {
                                toastDiv.remove();
                            }, 5000);
                        }
                        
                        console.log("Polígonos históricos cargados correctamente");
                        
                        // Cargar también polígonos actuales con traslapes si hay un polygon_id
                        if (polygon_id) {
                            cargarPoligonosActualesTraslapes(map, polygon_id);
                        }
                    })
                    .catch(error => {
                        console.error("Error al cargar polígonos históricos:", error);
                    });
            }
            
            // Función para cargar polígonos actuales con traslapes
            function cargarPoligonosActualesTraslapes(map, polygon_id) {
                if (!polygon_id) {
                    console.log("No se especificó ID de polígono para buscar traslapes actuales");
                    return;
                }
                
                console.log("Cargando polígonos actuales que traslapan...");
                
                var url = `/get-poligonos-actuales-traslapes/${polygon_id}`;
                
                fetch(url)
                    .then(response => response.json())
                    .then(data => {
                        if (data.error) {
                            console.error("Error al cargar polígonos actuales con traslapes:", data.error);
                            return;
                        }
                        
                        // Actualizar el dropdown con los IDs de polígonos actuales traslapados
                        var descripcionIdSelect = document.getElementById('DescripcionIdSelect');
                        if (descripcionIdSelect && data.poligonos_traslapados) {
                            // Añadir nuevas opciones con los IDs de polígonos actuales que traslapan
                            data.poligonos_traslapados.forEach(function(poligono) {
                                var option = document.createElement('option');
                                option.value = poligono.id_poligono;
                                option.textContent = "Actual: " + poligono.id_poligono;
                                descripcionIdSelect.appendChild(option);
                            });
                        }
                        
                        // Dibujar los polígonos actuales traslapados en el mapa si hay datos GeoJSON
                        if (data.geojson && data.geojson.features && data.geojson.features.length > 0) {
                            console.log("Dibujando polígonos actuales traslapados en el mapa...");
                            
                            // Limpiar capas actuales anteriores
                            actualesLayerGroup.clearLayers();
                            
                            // Crear capa para polígonos actuales traslapados con estilo diferente
                            var poligonosActualesLayer = L.geoJSON(data.geojson, {
                                style: function(feature) {
                                    return {
                                        fillColor: '#ff6b6b', // Rojo claro para polígonos actuales
                                        weight: 2,
                                        opacity: 1,
                                        color: '#d63031', // Borde rojo más oscuro
                                        dashArray: '5,5', // Línea punteada para distinguir de históricos
                                        fillOpacity: 0.5,
                                        pane: 'shadowPane', // Usar un pane con menor prioridad que overlayPane
                                        interactive: true // Permitir interacción para tooltips y popups
                                    };
                                },
                                onEachFeature: function(feature, layer) {
                                    // Crear tooltip rápido para información básica
                                    var tooltipContent = '';
                                    if (feature.properties.id_poligono) {
                                        tooltipContent += '<b>ID:</b> ' + feature.properties.id_poligono;
                                    }
                                    if (feature.properties.area) {
                                        tooltipContent += '<br><b>Área:</b> ' + parseFloat(feature.properties.area).toFixed(4) + ' ha';
                                    }
                                    if (tooltipContent) {
                                        layer.bindTooltip(tooltipContent, {
                                            permanent: false,
                                            direction: 'auto',
                                            opacity: 0.9,
                                            className: 'custom-tooltip-actual'
                                        });
                                    }
                                    
                                    // Crear popup con información del polígono actual traslapado
                                    var popupContent = '<div class="popup-content">';
                                    popupContent += '<h6><strong>Polígono Actual Traslapado</strong></h6>';
                                    popupContent += '<table class="table table-sm">';
                                    
                                    if (feature.properties.id_poligono) {
                                        popupContent += '<tr><td><strong>ID Polígono:</strong></td><td>' + feature.properties.id_poligono + '</td></tr>';
                                    }
                                    if (feature.properties.area) {
                                        popupContent += '<tr><td><strong>Área:</strong></td><td>' + parseFloat(feature.properties.area).toFixed(4) + ' ha</td></tr>';
                                    }
                                    if (feature.properties.estado) {
                                        popupContent += '<tr><td><strong>Estado:</strong></td><td>' + feature.properties.estado + '</td></tr>';
                                    }
                                    if (feature.properties.municipio) {
                                        popupContent += '<tr><td><strong>Municipio:</strong></td><td>' + feature.properties.municipio + '</td></tr>';
                                    }
                                    
                                    popupContent += '</table>';
                                    popupContent += '<small class="text-muted">⚠️ Este polígono traslapa con el polígono actual</small>';
                                    popupContent += '</div>';
                                    
                                    layer.bindPopup(popupContent);
                                    
                                    // Resaltar al pasar el mouse
                                    layer.on('mouseover', function(e) {
                                        var layer = e.target;
                                        layer.setStyle({
                                            weight: 4,
                                            fillOpacity: 0.7
                                        });
                                        layer.bringToFront();
                                    });
                                    
                                    layer.on('mouseout', function(e) {
                                        var layer = e.target;
                                        layer.setStyle({
                                            weight: 2,
                                            fillOpacity: 0.5
                                        });
                                    });
                                }
                            });
                            
                            // Añadir la capa al grupo de capas actuales
                            poligonosActualesLayer.addTo(actualesLayerGroup);
                            
                            // Guardar referencia para poder removerla después si es necesario
                            if (!window.poligonosActualesLayers) {
                                window.poligonosActualesLayers = [];
                            }
                            window.poligonosActualesLayers.push(poligonosActualesLayer);
                            
                            console.log(`${data.geojson.features.length} polígonos actuales traslapados dibujados en el mapa con estilo rojo punteado`);
                        }
                        
                        // Mostrar notificación si hay traslapes
                        if (data.total > 0) {
                            var toastHTML = `
                            <div class="toast-container position-fixed bottom-0 end-0 p-3">
                              <div class="toast show" role="alert" aria-live="assertive" aria-atomic="true">
                                <div class="toast-header">
                                  <strong class="me-auto">Polígonos Actuales</strong>
                                  <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
                                </div>
                                <div class="toast-body bg-warning">
                                  ⚠️ Se detectaron ${data.total} polígonos del archivo actual que traslapan con este polígono.
                                </div>
                              </div>
                            </div>`;
                            
                            var toastDiv = document.createElement('div');
                            toastDiv.innerHTML = toastHTML;
                            document.body.appendChild(toastDiv);
                            
                            // Eliminar el toast después de 8 segundos
                            setTimeout(function() {
                                toastDiv.remove();
                            }, 8000);
                        }
                        
                        console.log(`Polígonos actuales con traslapes cargados: ${data.total} encontrados`);
                    })
                    .catch(error => {
                        console.error("Error al cargar polígonos actuales con traslapes:", error);
                    });
            }
            
            // Añadir evento al botón de detectar ubicación
            var btnDetectarUbicacion = document.getElementById('btnDetectarUbicacion');
            if (btnDetectarUbicacion) {
                btnDetectarUbicacion.addEventListener('click', detectarUbicacionPoligono);
            }
            
            // Función para limpiar los controles no deseados de Leaflet.Draw
            function cleanupLeafletDrawControls() {
                // Ocultar cualquier control de edición nativo que pueda haber aparecido
                var leafletDrawControls = document.querySelectorAll('.leaflet-draw');
                leafletDrawControls.forEach(function(control) {
                    control.style.display = 'none';
                });
                
                // Asegurarse de que nuestros controles personalizados están visibles
                var editPolygonBtn = document.getElementById('editPolygon');
                var drawNewPolygonBtn = document.getElementById('drawNewPolygon');
                var addVertexBtn = document.getElementById('addVertex');
                if (editPolygonBtn && !editingMode && !window.addVertexMode) {
                    editPolygonBtn.style.display = 'block';
                }
                if (drawNewPolygonBtn && !editingMode && !window.addVertexMode) {
                    drawNewPolygonBtn.style.display = 'block';
                }
                if (addVertexBtn && !editingMode && !window.addVertexMode) {
                    addVertexBtn.style.display = 'block';
                }
                
                // Ocultar cualquier otro control de edición que pueda aparecer
                document.querySelectorAll('.leaflet-draw-edit-edit, .leaflet-draw-edit-remove').forEach(function(el) {
                    el.style.display = 'none';
                });
            }
            
            // Función para asegurar que el botón de edición funciona correctamente
            function reiniciarBotonEdicion() {
                // Obtener referencia al botón
                var editPolygonBtn = document.getElementById('editPolygon');
                var drawNewPolygonBtn = document.getElementById('drawNewPolygon');
                
                if (editPolygonBtn) {
                    // Remover cualquier evento click existente para evitar duplicados
                    var nuevoBoton = editPolygonBtn.cloneNode(true);
                    editPolygonBtn.parentNode.replaceChild(nuevoBoton, editPolygonBtn);
                    
                    // Añadir el evento click de nuevo
                    nuevoBoton.addEventListener('click', function(e) {
                        // Detener inmediatamente cualquier comportamiento predeterminado
                        if (e && e.preventDefault) e.preventDefault();
                        if (e && e.stopPropagation) e.stopPropagation();
                        
                        editingMode = true;
                        
                        // Mostrar botones de guardar y cancelar
                        document.getElementById('savePolygonChanges').style.display = 'block';
                        document.getElementById('cancelPolygonChanges').style.display = 'block';
                        document.getElementById('editPolygon').style.display = 'none';
                        document.getElementById('drawNewPolygon').style.display = 'none';
                        document.getElementById('addVertex').style.display = 'block';
                        
                        // Mostrar indicador de modo de edición e instrucciones
                        document.querySelector('.editing-mode-indicator').style.display = 'block';
                        document.querySelector('.edit-instructions').style.display = 'block';
                        
                        // Desactivar el formulario completamente durante la edición
                        var formInputs = document.querySelectorAll('#formEditarPoligono input, #formEditarPoligono textarea, #formEditarPoligono select');
                        formInputs.forEach(function(input) {
                            if (input.id !== 'COORDENADAS_DECIMALES_CORREGIDAS' && input.id !== 'Area_digitalizada') {
                                input.setAttribute('disabled', 'disabled');
                            }
                        });
                        
                        // Desactivar botón de envío del formulario
                        var submitButton = document.querySelector('#formEditarPoligono button[type="submit"]');
                        if (submitButton) {
                            submitButton.setAttribute('disabled', 'disabled');
                        }
                        
                        // Activar edición personalizada del polígono
                        editableLayers.eachLayer(function(layer) {
                            if (layer instanceof L.Polygon) {
                                // Cambiar estilo
                                layer.setStyle({color: '#ff4500', weight: 3, fillOpacity: 0.3});
                                
                                // Desactivar cualquier edición existente
                                if (layer.editing && layer.editing.enabled()) {
                                    layer.editing.disable();
                                }
                                
                                // Crear y activar editor personalizado
                                customEditor = createCustomVertexEditor(map, layer).enable();
                                
                                // Asegurar que el polígono esté por encima de los históricos
                                bringCurrentPolygonToFront();
                            }
                        });
                        
                        // Desactivar botones del formulario durante la edición
                        var formButtons = document.querySelectorAll('#formEditarPoligono button');
                        formButtons.forEach(function(btn) {
                            if (btn.id !== 'savePolygonChanges' && btn.id !== 'cancelPolygonChanges') {
                                btn.setAttribute('disabled', 'disabled');
                            }
                        });
                        
                        // Mostrar mensaje al usuario
                        var instructionToast = `
                        <div class="toast-container position-fixed bottom-0 end-0 p-3">
                          <div class="toast show" role="alert" aria-live="assertive" aria-atomic="true">
                            <div class="toast-header">
                              <strong class="me-auto">Modo Edición</strong>
                              <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
                            </div>
                            <div class="toast-body">
                              Ahora puedes mover los vértices existentes del polígono arrastrando los puntos blancos o agregar nuevos vértices.
                            </div>
                          </div>
                        </div>`;
                        
                        var toastDiv = document.createElement('div');
                        toastDiv.innerHTML = instructionToast;
                        document.body.appendChild(toastDiv);
                        
                        // Eliminar el toast después de 5 segundos
                        setTimeout(function() {
                            toastDiv.remove();
                        }, 5000);
                        
                        // Limpiar cualquier control de edición nativo
                        cleanupLeafletDrawControls();
                        
                        return false; // Evitar cualquier comportamiento adicional
                    });
                    
                    // Asegurarse de que el botón es visible
                    nuevoBoton.style.display = 'block';
                    nuevoBoton.disabled = false;
                }
                
                // Reiniciar el botón de agregar vértice
                var addVertexBtn = document.getElementById('addVertex');
                if (addVertexBtn) {
                    // Asegurarse de que el botón es visible y funcional
                    addVertexBtn.style.display = 'block';
                    addVertexBtn.disabled = false;
                }
                
                // Reiniciar el botón de dibujar nuevo polígono
                if (drawNewPolygonBtn) {
                    // Remover cualquier evento click existente
                    var nuevoBotonDibujo = drawNewPolygonBtn.cloneNode(true);
                    drawNewPolygonBtn.parentNode.replaceChild(nuevoBotonDibujo, drawNewPolygonBtn);
                    
                    // Añadir el evento click de nuevo
                    nuevoBotonDibujo.addEventListener('click', function(e) {
                        // Detener comportamiento predeterminado
                        if (e && e.preventDefault) e.preventDefault();
                        if (e && e.stopPropagation) e.stopPropagation();
                        
                        // Cambiar modo
                        editingMode = true;
                        drawingMode = true;
                        
                        // Ocultar botones de edición y dibujo nuevo, mostrar guardar y cancelar
                        document.getElementById('editPolygon').style.display = 'none';
                        document.getElementById('drawNewPolygon').style.display = 'none';
                        document.getElementById('savePolygonChanges').style.display = 'block';
                        document.getElementById('cancelPolygonChanges').style.display = 'block';
                        
                        // Mostrar indicadores
                        document.querySelector('.editing-mode-indicator').style.display = 'block';
                        document.querySelector('.editing-mode-indicator').innerHTML = 'DIBUJANDO NUEVO POLÍGONO';
                        document.querySelector('.edit-instructions').style.display = 'block';
                        document.querySelector('.edit-instructions').innerHTML = `
                            <h5>Cómo dibujar un nuevo polígono:</h5>
                            <ul>
                                <li><strong>Añadir vértice:</strong> Haz clic en el mapa para añadir puntos</li>
                                <li><strong>Finalizar polígono:</strong> Haz clic en el primer punto o doble clic en el último punto</li>
                            </ul>
                        `;
                        
                        // Desactivar campos del formulario durante el dibujo
                        var formInputs = document.querySelectorAll('#formEditarPoligono input, #formEditarPoligono textarea, #formEditarPoligono select');
                        formInputs.forEach(function(input) {
                            if (input.id !== 'COORDENADAS_DECIMALES_CORREGIDAS' && input.id !== 'Area_digitalizada') {
                                input.setAttribute('disabled', 'disabled');
                            }
                        });
                        
                        // Desactivar botón de envío del formulario
                        var submitButton = document.querySelector('#formEditarPoligono button[type="submit"]');
                        if (submitButton) {
                            submitButton.setAttribute('disabled', 'disabled');
                        }
                        
                        // Guardar el polígono actual como referencia (no eliminarlo)
                        editableLayers.eachLayer(function(layer) {
                            if (layer instanceof L.Polygon) {
                                layer.setStyle({color: '#aaaaaa', weight: 2, fillOpacity: 0.1, dashArray: '5, 5'});
                            }
                        });
                        
                        // Crear control de dibujo
                        drawControl = new L.Draw.Polygon(map, {
                            shapeOptions: {
                                color: '#ff4500',
                                weight: 3,
                                fillOpacity: 0.3
                            }
                        });
                        
                        // Iniciar dibujo
                        drawControl.enable();
                        
                        // Habilitar navegación durante el dibujo
                        map.dragging.enable();
                        map.scrollWheelZoom.enable();
                        map.doubleClickZoom.enable();
                        map.touchZoom.enable();
                        
                        // Mostrar mensaje al usuario
                        var instructionToast = `
                        <div class="toast-container position-fixed bottom-0 end-0 p-3">
                          <div class="toast show" role="alert" aria-live="assertive" aria-atomic="true">
                            <div class="toast-header">
                              <strong class="me-auto">Dibujando Nuevo Polígono</strong>
                              <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
                            </div>
                            <div class="toast-body">
                              Haz clic en el mapa para añadir puntos. Cierra el polígono haciendo clic en el primer punto o doble clic.
                            </div>
                          </div>
                        </div>`;
                        
                        var toastDiv = document.createElement('div');
                        toastDiv.innerHTML = instructionToast;
                        document.body.appendChild(toastDiv);
                        
                        // Eliminar el toast después de 5 segundos
                        setTimeout(function() {
                            toastDiv.remove();
                        }, 5000);
                        
                        return false;
                    });
                    
                    // Asegurarse de que el botón es visible
                    nuevoBotonDibujo.style.display = 'block';
                    nuevoBotonDibujo.disabled = false;
                }
            }
            
            // Ejecutar limpieza inicial y configurar intervalos regulares para limpiar controles no deseados
            setTimeout(cleanupLeafletDrawControls, 500);
            setInterval(cleanupLeafletDrawControls, 1000); // Ejecutar cada segundo para asegurar que los controles no deseados permanecen ocultos
            
            // Prevenir que el formulario se envíe mientras se edita
            var formEl = document.getElementById('formEditarPoligono');
            if (formEl) {
                formEl.addEventListener('submit', function(e) {
                    console.log('Intento de envío del formulario. editingMode:', window.editingMode);
                    
                    // Usar window.editingMode en lugar de la variable local
                    if (window.editingMode === true) {
                        e.preventDefault();
                        alert('Por favor guarde o cancele la edición del polígono antes de guardar los cambios del formulario.');
                        return false;
                    }
                    
                    // Verificar y mostrar las coordenadas que se van a enviar
                    var coordsField = document.getElementById('COORDENADAS_DECIMALES_CORREGIDAS');
                    if (coordsField) {
                        console.log('Coordenadas que se enviarán al servidor:', coordsField.value);
                        console.log('Nombre del campo:', coordsField.name);
                    }
                    
                    // Permitir el envío normal si no estamos en modo de edición
                    console.log('Formulario enviado normalmente');
                    return true;
                });
            }
            
            // Indicador de modo de edición
            var editingIndicator = L.control({position: 'topleft'});
            editingIndicator.onAdd = function(map) {
                var div = L.DomUtil.create('div', 'editing-mode-indicator');
                div.innerHTML = 'MODO EDICIÓN ACTIVO';
                return div;
            };
            editingIndicator.addTo(map);
            
            // Instrucciones de edición
            var editInstructions = L.control({position: 'bottomleft'});
            editInstructions.onAdd = function(map) {
                var div = L.DomUtil.create('div', 'edit-instructions');
                div.innerHTML = `
                    <h5>Cómo editar el polígono:</h5>
                    <ul>
                        <li><strong>Mover vértice:</strong> Haz clic y arrastra cualquier punto blanco</li>
                        <li><strong>Eliminar vértice:</strong> Haz clic en un vértice mientras mantienes presionada la tecla Ctrl</li>
                    </ul>
                `;
                return div;
            };
            editInstructions.addTo(map);
            
            // Boton personalizado para activar edición
            var editButton = L.control({position: 'topright'});
            editButton.onAdd = function(map) {
                var div = L.DomUtil.create('div', 'edit-polygon-btn custom-leaflet-btn');
                div.innerHTML = '<button type="button" class="btn btn-primary btn-sm" id="editPolygon"><i class="bi bi-pencil"></i> Editar Polígono</button>';
                return div;
            };
            editButton.addTo(map);
            
            // Botón para dibujar nuevo polígono
            var drawNewButton = L.control({position: 'topright'});
            drawNewButton.onAdd = function(map) {
                var div = L.DomUtil.create('div', 'draw-new-btn custom-leaflet-btn');
                div.innerHTML = '<button type="button" class="btn btn-warning btn-sm" id="drawNewPolygon"><i class="bi bi-pencil-square"></i> Dibujar Nuevo Polígono</button>';
                return div;
            };
            drawNewButton.addTo(map);
            
            // Botón para agregar vértice
            var addVertexButton = L.control({position: 'topright'});
            addVertexButton.onAdd = function(map) {
                var div = L.DomUtil.create('div', 'add-vertex-btn custom-leaflet-btn');
                div.innerHTML = '<button type="button" class="btn btn-info btn-sm" id="addVertex"><i class="bi bi-plus-circle"></i> Agregar Vértice</button>';
                return div;
            };
            addVertexButton.addTo(map);
            
            // Botón para guardar cambios
            var saveChangesBtn = L.control({position: 'topright'});
            saveChangesBtn.onAdd = function(map) {
                var div = L.DomUtil.create('div', 'save-changes-btn custom-leaflet-btn');
                div.innerHTML = '<button type="button" class="btn btn-success btn-sm" id="savePolygonChanges" style="display:none;"><i class="bi bi-check-lg"></i> Guardar</button>';
                return div;
            };
            saveChangesBtn.addTo(map);
            
            // Botón para cancelar cambios
            var cancelChangesBtn = L.control({position: 'topright'});
            cancelChangesBtn.onAdd = function(map) {
                var div = L.DomUtil.create('div', 'cancel-changes-btn custom-leaflet-btn');
                div.innerHTML = '<button type="button" class="btn btn-danger btn-sm" id="cancelPolygonChanges" style="display:none;"><i class="bi bi-x-lg"></i> Cancelar</button>';
                return div;
            };
            cancelChangesBtn.addTo(map);
            
            // Función para deshabilitar los marcadores medios
            function disableMiddleMarkers(layer) {
                if (layer && layer.editing && layer.editing._verticesHandlers) {
                    layer.editing._verticesHandlers.forEach(function(handler) {
                        // Guardar referencia a la función original
                        handler._origCreateMiddleMarker = handler._createMiddleMarker;
                        
                        // Reemplazar con función vacía
                        handler._createMiddleMarker = function() { return null; };
                        
                        // Eliminar marcadores medios existentes
                        if (handler._middleMarkers) {
                            handler._middleMarkers.forEach(function(marker) {
                                if (marker._map) marker._map.removeLayer(marker);
                            });
                            handler._middleMarkers = [];
                        }
                    });
                }
            }
            
            // Crear un editor personalizado que solo permita mover vértices existentes
            function createCustomVertexEditor(map, polygon) {
                // Desactivar edición nativa
                if (polygon.editing && polygon.editing.enabled()) {
                    polygon.editing.disable();
                }
                
                var markerGroup = new L.LayerGroup().addTo(map);
                var vertexMarkers = [];
                var vertices = polygon.getLatLngs()[0];
                
                // Crear un marcador para cada vértice del polígono
                vertices.forEach(function(latlng, index) {
                    var marker = L.marker(latlng, {
                        draggable: true,
                        icon: L.divIcon({
                            className: 'vertex-marker',
                            html: '<div style="width: 12px; height: 12px; background-color: white; border: 2px solid #333; border-radius: 50%;"></div>',
                            iconSize: [12, 12],
                            iconAnchor: [6, 6]
                        })
                    }).addTo(markerGroup);
                    
                    // Al arrastrar un marcador, actualizar el polígono
                    marker.on('drag', function(e) {
                        updatePolygon();
                    });
                    
                    // Al empezar a arrastrar, cambiar el estilo
                    marker.on('dragstart', function(e) {
                        var markerElement = e.target._icon.querySelector('div');
                        markerElement.style.backgroundColor = '#ff4500';
                        markerElement.style.borderColor = 'white';
                        markerElement.style.transform = 'scale(1.3)';
                    });
                    
                    // Al terminar de arrastrar, restaurar estilo
                    marker.on('dragend', function(e) {
                        var markerElement = e.target._icon.querySelector('div');
                        markerElement.style.backgroundColor = 'white';
                        markerElement.style.borderColor = '#333';
                        markerElement.style.transform = 'scale(1)';
                        updatePolygon();
                    });
                    
                    vertexMarkers.push(marker);
                });
                
                // Función para actualizar el polígono basado en las posiciones actuales de los marcadores
                function updatePolygon() {
                    var newLatLngs = vertexMarkers.map(function(marker) {
                        return marker.getLatLng();
                    });
                    polygon.setLatLngs(newLatLngs);
                    
                    // Calcular y actualizar el área digitalizada en tiempo real
                    var areaSqMeters = L.GeometryUtil.geodesicArea(newLatLngs);
                    var areaHectares = areaSqMeters / 10000; // Convertir a hectáreas
                    document.getElementById('Area_digitalizada').value = areaHectares.toFixed(4);
                    
                    // Calcular estatus automáticamente
                    if (typeof calcularEstatus === 'function') calcularEstatus();
                }
                
                return {
                    enable: function() {
                        markerGroup.addTo(map);
                        return this;
                    },
                    disable: function() {
                        markerGroup.clearLayers();
                        map.removeLayer(markerGroup);
                        return this;
                    },
                    getMarkers: function() {
                        return vertexMarkers;
                    },
                    updatePolygon: updatePolygon
                };
            }
            
            // Crear un editor para agregar vértices al hacer clic en las líneas
            function createAddVertexEditor(map, polygon) {
                var isActive = false;
                var originalClickHandler = null;
                
                function enable() {
                    if (isActive) return;
                    isActive = true;
                    
                    // Cambiar el cursor del mapa
                    map.getContainer().style.cursor = 'crosshair';
                    
                    // Cambiar el estilo del polígono para indicar modo de adición
                    polygon.setStyle({
                        color: '#17a2b8',
                        weight: 4,
                        fillOpacity: 0.3,
                        opacity: 0.8
                    });
                    
                    // Agregar evento de clic al polígono
                    polygon.on('click', onPolygonClick);
                    
                    // Asegurar que el polígono esté por encima de los históricos
                    if (typeof bringCurrentPolygonToFront === 'function') {
                        bringCurrentPolygonToFront();
                    }
                    
                    return this;
                }
                
                function disable() {
                    if (!isActive) return;
                    isActive = false;
                    
                    // Restaurar cursor
                    map.getContainer().style.cursor = '';
                    
                    // Restaurar estilo del polígono
                    polygon.setStyle({
                        color: '#0066cc',
                        weight: 3,
                        fillOpacity: 0.2,
                        opacity: 1
                    });
                    
                    // Remover evento de clic
                    polygon.off('click', onPolygonClick);
                    
                    return this;
                }
                
                function onPolygonClick(e) {
                    // Obtener las coordenadas del clic
                    var clickLatLng = e.latlng;
                    var currentLatLngs = polygon.getLatLngs()[0];
                    
                    // Encontrar el segmento más cercano al punto de clic
                    var closestSegment = findClosestSegment(clickLatLng, currentLatLngs);
                    
                    if (closestSegment !== null) {
                        // Insertar el nuevo vértice después del índice encontrado
                        var newLatLngs = [...currentLatLngs];
                        newLatLngs.splice(closestSegment.insertIndex, 0, clickLatLng);
                        
                        // Actualizar el polígono
                        polygon.setLatLngs(newLatLngs);
                        
                        // Calcular y actualizar el área
                        var areaSqMeters = L.GeometryUtil.geodesicArea(newLatLngs);
                        var areaHectares = areaSqMeters / 10000;
                        var areaField = document.getElementById('Area_digitalizada');
                        if (areaField) {
                            areaField.value = areaHectares.toFixed(4);
                            highlightField('Area_digitalizada');
                        }
                        
                        // Actualizar coordenadas en el campo de texto
                        var coordsText = newLatLngs.map(function(latLng) {
                            return latLng.lat.toFixed(6) + ',' + latLng.lng.toFixed(6);
                        }).join(' | ');
                        
                        var coordsField = document.getElementById('COORDENADAS_DECIMALES_CORREGIDAS');
                        if (coordsField) {
                            coordsField.value = coordsText;
                            coordsField.setAttribute('data-polygon-coords', coordsText);
                            highlightField('COORDENADAS_DECIMALES_CORREGIDAS');
                        }
                        
                        // Calcular estatus automáticamente
                        if (typeof calcularEstatus === 'function') calcularEstatus();
                        
                        // Mostrar un mensaje temporal
                        showTemporaryMessage('Vértice agregado exitosamente. Ahora puedes arrastrarlo.', 'success');
                        
                        console.log('Nuevo vértice agregado en posición:', closestSegment.insertIndex);
                        
                        // Desactivar el modo de agregar vértice
                        disable();
                        
                        // Activar automáticamente el editor de vértices para poder arrastrar todos los puntos
                        if (typeof createCustomVertexEditor === 'function') {
                                                         // Crear y activar el editor de vértices personalizado
                             window.customEditor = createCustomVertexEditor(map, polygon);
                             window.customEditor.enable();
                             
                             // Asegurar que el polígono esté por encima después de agregar el vértice
                             bringCurrentPolygonToFront();
                             
                             // Cambiar a modo de edición estándar
                             window.editingMode = true;
                             window.addVertexMode = false;
                            
                            // Actualizar la interfaz para mostrar que estamos en modo edición de vértices
                            document.querySelector('.editing-mode-indicator').innerHTML = 'EDITANDO VÉRTICES';
                            document.querySelector('.edit-instructions').innerHTML = `
                                <h5>Vértice agregado - Modo edición activo:</h5>
                                <ul>
                                    <li><strong>Mover vértice:</strong> Arrastra cualquier punto blanco para moverlo</li>
                                    <li><strong>Agregar más vértices:</strong> Haz clic en "Agregar Vértice" nuevamente</li>
                                    <li><strong>Guardar cambios:</strong> Haz clic en "Guardar" cuando termines</li>
                                </ul>
                            `;
                            
                            // Mostrar botones relevantes
                            document.getElementById('editPolygon').style.display = 'none';
                            document.getElementById('drawNewPolygon').style.display = 'none';
                            document.getElementById('addVertex').style.display = 'block';
                            document.getElementById('savePolygonChanges').style.display = 'block';
                            document.getElementById('cancelPolygonChanges').style.display = 'block';
                        }
                    }
                }
                
                function findClosestSegment(clickPoint, vertices) {
                    var minDistance = Infinity;
                    var closestSegment = null;
                    
                    for (var i = 0; i < vertices.length; i++) {
                        var start = vertices[i];
                        var end = vertices[(i + 1) % vertices.length];
                        
                        // Calcular la distancia del punto al segmento
                        var distance = distanceToSegment(clickPoint, start, end);
                        
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestSegment = {
                                segmentIndex: i,
                                insertIndex: i + 1,
                                distance: distance
                            };
                        }
                    }
                    
                    return closestSegment;
                }
                
                function distanceToSegment(point, segStart, segEnd) {
                    // Convertir a coordenadas planas para el cálculo
                    var px = point.lng;
                    var py = point.lat;
                    var sx1 = segStart.lng;
                    var sy1 = segStart.lat;
                    var sx2 = segEnd.lng;
                    var sy2 = segEnd.lat;
                    
                    var A = px - sx1;
                    var B = py - sy1;
                    var C = sx2 - sx1;
                    var D = sy2 - sy1;
                    
                    var dot = A * C + B * D;
                    var lenSq = C * C + D * D;
                    var param = -1;
                    
                    if (lenSq !== 0) {
                        param = dot / lenSq;
                    }
                    
                    var xx, yy;
                    
                    if (param < 0) {
                        xx = sx1;
                        yy = sy1;
                    } else if (param > 1) {
                        xx = sx2;
                        yy = sy2;
                    } else {
                        xx = sx1 + param * C;
                        yy = sy1 + param * D;
                    }
                    
                    var dx = px - xx;
                    var dy = py - yy;
                    
                    return Math.sqrt(dx * dx + dy * dy);
                }
                
                return {
                    enable: enable,
                    disable: disable,
                    isActive: function() { return isActive; }
                };
            }
            
            // Función para asegurar que el polígono actual esté siempre por encima
            function bringCurrentPolygonToFront() {
                editableLayers.eachLayer(function(layer) {
                    if (layer instanceof L.Polygon) {
                        // Traer el polígono al frente
                        layer.bringToFront();
                        console.log("Polígono actual traído al frente para evitar conflictos con capas históricas");
                    }
                });
            }
            
            // Función para mostrar mensajes temporales
            function showTemporaryMessage(message, type) {
                type = type || 'info';
                var alertClass = 'alert-' + type;
                
                var messageDiv = document.createElement('div');
                messageDiv.className = `alert ${alertClass} position-fixed`;
                messageDiv.style.top = '20px';
                messageDiv.style.right = '20px';
                messageDiv.style.zIndex = '2000';
                messageDiv.style.minWidth = '300px';
                messageDiv.innerHTML = `
                    <div class="d-flex align-items-center">
                        <i class="bi bi-check-circle me-2"></i>
                        <span>${message}</span>
                    </div>
                `;
                
                document.body.appendChild(messageDiv);
                
                // Animar entrada
                messageDiv.style.opacity = '0';
                messageDiv.style.transform = 'translateX(100%)';
                setTimeout(function() {
                    messageDiv.style.transition = 'all 0.3s ease';
                    messageDiv.style.opacity = '1';
                    messageDiv.style.transform = 'translateX(0)';
                }, 10);
                
                // Remover después de 3 segundos
                setTimeout(function() {
                    messageDiv.style.transition = 'all 0.3s ease';
                    messageDiv.style.opacity = '0';
                    messageDiv.style.transform = 'translateX(100%)';
                    setTimeout(function() {
                        if (messageDiv.parentNode) {
                            messageDiv.parentNode.removeChild(messageDiv);
                        }
                    }, 300);
                }, 3000);
            }
            
            // Variable para guardar la referencia al editor personalizado
            var customEditor = null;
            var addVertexEditor = null;
            
            // Función para resaltar visualmente un campo cuando se actualiza
            function highlightField(fieldId) {
                var field = document.getElementById(fieldId);
                if (field) {
                    field.style.transition = 'background-color 0.5s';
                    field.style.backgroundColor = '#ffffcc';
                    setTimeout(function() {
                        field.style.backgroundColor = '';
                    }, 1000);
                }
            }
            
            // Inicializar el botón de edición
            reiniciarBotonEdicion();
            
            // Variable para control de dibujo nuevo
            var drawControl = null;
            var drawingMode = false;
            
            // Manejar el botón de dibujar nuevo polígono
            document.getElementById('drawNewPolygon').addEventListener('click', function(e) {
                // Detener comportamiento predeterminado
                if (e && e.preventDefault) e.preventDefault();
                if (e && e.stopPropagation) e.stopPropagation();
                
                console.log("Iniciando modo de dibujo de nuevo polígono");
                
                // Cambiar modo
                editingMode = true;
                drawingMode = true;
                
                // Ocultar botones de edición y dibujo nuevo, mostrar guardar y cancelar
                document.getElementById('editPolygon').style.display = 'none';
                document.getElementById('drawNewPolygon').style.display = 'none';
                document.getElementById('savePolygonChanges').style.display = 'block';
                document.getElementById('cancelPolygonChanges').style.display = 'block';
                
                // Mostrar indicadores
                document.querySelector('.editing-mode-indicator').style.display = 'block';
                document.querySelector('.editing-mode-indicator').innerHTML = 'DIBUJANDO NUEVO POLÍGONO';
                document.querySelector('.edit-instructions').style.display = 'block';
                document.querySelector('.edit-instructions').innerHTML = `
                    <h5>Cómo dibujar un nuevo polígono:</h5>
                    <ul>
                        <li><strong>Añadir vértice:</strong> Haz clic en el mapa para añadir puntos</li>
                        <li><strong>Finalizar polígono:</strong> Haz clic en el primer punto o doble clic en el último punto</li>
                    </ul>
                `;
                
                // Desactivar campos del formulario durante el dibujo
                var formInputs = document.querySelectorAll('#formEditarPoligono input, #formEditarPoligono textarea, #formEditarPoligono select');
                formInputs.forEach(function(input) {
                    if (input.id !== 'COORDENADAS_DECIMALES_CORREGIDAS' && input.id !== 'Area_digitalizada') {
                        input.setAttribute('disabled', 'disabled');
                    }
                });
                
                // Desactivar botón de envío del formulario
                var submitButton = document.querySelector('#formEditarPoligono button[type="submit"]');
                if (submitButton) {
                    submitButton.setAttribute('disabled', 'disabled');
                }
                
                // Guardar el polígono actual como referencia (no eliminarlo)
                editableLayers.eachLayer(function(layer) {
                    if (layer instanceof L.Polygon) {
                        layer.setStyle({color: '#aaaaaa', weight: 2, fillOpacity: 0.1, dashArray: '5, 5'});
                    }
                });
                
                // Crear control de dibujo
                drawControl = new L.Draw.Polygon(map, {
                    shapeOptions: {
                        color: '#ff4500',
                        weight: 3,
                        fillOpacity: 0.3
                    }
                });
                
                // Iniciar dibujo
                drawControl.enable();
                
                // Habilitar navegación durante el dibujo
                map.dragging.enable();
                map.scrollWheelZoom.enable();
                map.doubleClickZoom.enable();
                map.touchZoom.enable();
                
                // Mostrar mensaje al usuario
                var instructionToast = `
                <div class="toast-container position-fixed bottom-0 end-0 p-3">
                  <div class="toast show" role="alert" aria-live="assertive" aria-atomic="true">
                    <div class="toast-header">
                      <strong class="me-auto">Dibujando Nuevo Polígono</strong>
                      <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
                    </div>
                    <div class="toast-body">
                      Haz clic en el mapa para añadir puntos. Cierra el polígono haciendo clic en el primer punto o doble clic.
                    </div>
                  </div>
                </div>`;
                
                var toastDiv = document.createElement('div');
                toastDiv.innerHTML = instructionToast;
                document.body.appendChild(toastDiv);
                
                // Eliminar el toast después de 5 segundos
                setTimeout(function() {
                    toastDiv.remove();
                }, 5000);
                
                return false;
            });
            
            // Manejar el botón de agregar vértice
            document.getElementById('addVertex').addEventListener('click', function(e) {
                // Detener comportamiento predeterminado
                if (e && e.preventDefault) e.preventDefault();
                if (e && e.stopPropagation) e.stopPropagation();
                
                // Verificar que hay un polígono para editar
                var polygonExists = false;
                editableLayers.eachLayer(function(layer) {
                    if (layer instanceof L.Polygon) {
                        polygonExists = true;
                    }
                });
                
                if (!polygonExists) {
                    alert('No hay polígono disponible para agregar vértices. Por favor, cargue un polígono primero.');
                    return false;
                }
                
                console.log("Iniciando modo de agregar vértice");
                
                // Si ya hay un customEditor activo, desactivarlo primero
                if (window.customEditor) {
                    window.customEditor.disable();
                    window.customEditor = null;
                }
                
                // Cambiar modo
                window.addVertexMode = true;
                window.editingMode = true; // También activar modo de edición
                
                // Configurar la interfaz según si ya estamos en modo de edición o no
                if (!document.getElementById('savePolygonChanges').style.display || 
                    document.getElementById('savePolygonChanges').style.display === 'none') {
                    // Venimos del estado inicial
                    document.getElementById('editPolygon').style.display = 'none';
                    document.getElementById('drawNewPolygon').style.display = 'none';
                    document.getElementById('savePolygonChanges').style.display = 'block';
                    document.getElementById('cancelPolygonChanges').style.display = 'block';
                    
                    // Desactivar campos del formulario durante la edición
                    var formInputs = document.querySelectorAll('#formEditarPoligono input, #formEditarPoligono textarea, #formEditarPoligono select');
                    formInputs.forEach(function(input) {
                        if (input.id !== 'COORDENADAS_DECIMALES_CORREGIDAS' && input.id !== 'Area_digitalizada') {
                            input.setAttribute('disabled', 'disabled');
                        }
                    });
                    
                    // Desactivar botón de envío del formulario
                    var submitButton = document.querySelector('#formEditarPoligono button[type="submit"]');
                    if (submitButton) {
                        submitButton.setAttribute('disabled', 'disabled');
                    }
                }
                
                // Mantener el botón de agregar vértice visible
                document.getElementById('addVertex').style.display = 'block';
                
                // Mostrar indicadores
                document.querySelector('.editing-mode-indicator').style.display = 'block';
                document.querySelector('.editing-mode-indicator').innerHTML = 'AGREGANDO VÉRTICES';
                document.querySelector('.edit-instructions').style.display = 'block';
                document.querySelector('.edit-instructions').innerHTML = `
                    <h5>Cómo agregar vértices:</h5>
                    <ul>
                        <li><strong>Agregar vértice:</strong> Haz clic en cualquier línea del polígono donde quieras agregar un nuevo punto</li>
                        <li><strong>El nuevo vértice se insertará automáticamente y se activará el modo de edición</strong></li>
                        <li><strong>Guardar cambios:</strong> Haz clic en el botón Guardar cuando hayas terminado</li>
                    </ul>
                `;
                
                // Activar el editor de agregar vértices
                editableLayers.eachLayer(function(layer) {
                    if (layer instanceof L.Polygon) {
                        if (addVertexEditor) {
                            addVertexEditor.disable();
                        }
                        addVertexEditor = createAddVertexEditor(map, layer);
                        addVertexEditor.enable();
                        
                        // Asegurar que el polígono esté por encima de los históricos
                        bringCurrentPolygonToFront();
                    }
                });
                
                // Mostrar mensaje al usuario
                showTemporaryMessage('Haz clic en las líneas del polígono para agregar nuevos vértices', 'info');
                
                return false;
            });
            
            // Configurar un único evento draw:created para todo el mapa
            map.off('draw:created'); // Eliminar cualquier manejador previo
            map.on('draw:created', function(e) {
                console.log("Evento draw:created detectado:", e.layerType);
                if (e.layerType === 'polygon') {
                    console.log("Procesando nuevo polígono dibujado");
                    
                    // Obtener el nuevo polígono
                    var newPolygon = e.layer;
                    
                    // Mostrar información sobre el polígono
                    console.log("Puntos del polígono:", newPolygon.getLatLngs()[0].length);
                    
                    // Eliminar el polígono de referencia (gris) y añadir el nuevo
                    editableLayers.clearLayers();
                    editableLayers.addLayer(newPolygon);
                    
                    // Calcular y actualizar el área
                    var areaSqMeters = L.GeometryUtil.geodesicArea(newPolygon.getLatLngs()[0]);
                    var areaHectares = areaSqMeters / 10000;
                    var areaFormateada = areaHectares.toFixed(4);
                    console.log("Área calculada:", areaFormateada, "hectáreas");
                    
                    // Actualizar campos del formulario
                    var areaField = document.getElementById('Area_digitalizada');
                    if(areaField) {
                        areaField.value = areaFormateada;
                        highlightField('Area_digitalizada');
                        console.log("Campo de área actualizado a:", areaFormateada);
                        
                        // Guardar el valor como atributo de datos para asegurar que no se pierda
                        areaField.setAttribute('data-polygon-area', areaFormateada);
                        
                        // Calcular estatus automáticamente
                        if (typeof calcularEstatus === 'function') calcularEstatus();
                    } else {
                        console.error("No se encontró el campo Area_digitalizada");
                    }
                    
                    // Actualizar el campo de coordenadas corregidas con las nuevas coordenadas
                    var newLatLngs = newPolygon.getLatLngs()[0];
                    var newCoords = newLatLngs.map(function(latLng) {
                        return latLng.lat.toFixed(6) + ',' + latLng.lng.toFixed(6);
                    }).join(' | ');
                    console.log("Nuevas coordenadas del polígono dibujado:", newCoords);
                    
                    var coordsField = document.getElementById('COORDENADAS_DECIMALES_CORREGIDAS');
                    if(coordsField) {
                        coordsField.value = newCoords;
                        highlightField('COORDENADAS_DECIMALES_CORREGIDAS');
                        console.log("Campo de coordenadas actualizado exitosamente:", newCoords);
                        
                        // Verificar que el valor se guardó correctamente
                        console.log("Valor actual del campo después de la actualización:", coordsField.value);
                        
                        // Guardar el valor como atributo de datos para asegurar que no se pierda
                        coordsField.setAttribute('data-polygon-coords', newCoords);
                    } else {
                        console.error("No se encontró el campo COORDENADAS_DECIMALES_CORREGIDAS");
                    }
                    
                    // Preparar para edición de vértices una vez dibujado
                    customEditor = createCustomVertexEditor(map, newPolygon).enable();
                    
                    // Actualizar mensaje de instrucciones
                    document.querySelector('.edit-instructions').innerHTML = `
                        <h5>Polígono dibujado:</h5>
                        <ul>
                            <li><strong>Ajustar vértices:</strong> Ahora puedes mover los puntos blancos</li>
                            <li><strong>Guardar cambios:</strong> Haz clic en el botón Guardar</li>
                        </ul>
                    `;
                    
                    // Desactivar modo de dibujo pero mantener en modo de edición
                    drawingMode = false;
                    if (drawControl) {
                        drawControl.disable();
                        drawControl = null;
                    }
                    
                    // Notificar al usuario de la actualización
                    alert("Polígono dibujado. Se han actualizado las coordenadas y el área digitalizada.");
                    
                    // Mantener actualizados los campos - evitar que se restauren valores previos
                    setTimeout(function() {
                        // Verificar y restaurar los valores si fueron cambiados
                        verifyAndRestoreFields();
                    }, 500);
                }
            });
            
            // Funcionalidad para guardar cambios
            document.getElementById('savePolygonChanges').addEventListener('click', function(e) {
                // Detener inmediatamente cualquier comportamiento predeterminado
                if (e && e.preventDefault) e.preventDefault();
                if (e && e.stopPropagation) e.stopPropagation();
                
                // Si estamos en modo dibujo, desactivarlo
                if (drawControl && drawingMode) {
                    drawControl.disable();
                    drawControl = null;
                    drawingMode = false;
                }
                
                // Obtener las coordenadas actualizadas del polígono
                var updatedLatLngs = [];
                
                if (customEditor) {
                    // Asegurar que el polígono tiene los datos más recientes
                    customEditor.updatePolygon();
                }
                
                // Obtener coordenadas del polígono
                editableLayers.eachLayer(function(layer) {
                    if (layer instanceof L.Polygon) {
                        updatedLatLngs = layer.getLatLngs()[0];
                    }
                });
                
                console.log("Coordenadas actualizadas del polígono:", updatedLatLngs);
                
                // Formatear las coordenadas para guardarlas
                var updatedCoords = updatedLatLngs.map(function(latLng) {
                    return latLng.lat.toFixed(6) + ',' + latLng.lng.toFixed(6);
                }).join(' | ');
                
                console.log("Coordenadas formateadas para guardar:", updatedCoords);
                
                // Actualizar el campo de texto con las nuevas coordenadas
                var coordsField = document.getElementById('COORDENADAS_DECIMALES_CORREGIDAS');
                if(coordsField) {
                    coordsField.value = updatedCoords;
                    console.log("Campo COORDENADAS_DECIMALES_CORREGIDAS actualizado con:", updatedCoords);
                    
                    // Guardar el valor como atributo de datos para asegurar que no se pierda
                    coordsField.setAttribute('data-polygon-coords', updatedCoords);
                } else {
                    console.error("No se encontró el campo COORDENADAS_DECIMALES_CORREGIDAS");
                }
                
                // Asegurar que el área también esté actualizada
                var areaSqMeters = L.GeometryUtil.geodesicArea(updatedLatLngs);
                var areaHectares = areaSqMeters / 10000;
                var areaFormateada = areaHectares.toFixed(4);
                
                var areaField = document.getElementById('Area_digitalizada');
                areaField.value = areaFormateada;
                
                // Calcular estatus automáticamente con el nuevo valor del área
                if (typeof calcularEstatus === 'function') calcularEstatus();
                
                // Guardar el valor como atributo de datos para asegurar que no se pierda
                areaField.setAttribute('data-polygon-area', areaFormateada);
                
                // Añadir un efecto visual de actualización a los campos
                highlightField('COORDENADAS_DECIMALES_CORREGIDAS');
                highlightField('Area_digitalizada');
                
                // Desactivar editor personalizado
                if (customEditor) {
                    customEditor.disable();
                    customEditor = null;
                }
                
                // Desactivar editor personalizado global si estaba activo
                if (window.customEditor) {
                    window.customEditor.disable();
                    window.customEditor = null;
                }
                
                // Desactivar editor de agregar vértices si estaba activo
                if (addVertexEditor) {
                    addVertexEditor.disable();
                    addVertexEditor = null;
                }
                
                // Ocultar botones de guardar y cancelar, mostrar botones de editar y dibujar nuevo
                document.getElementById('savePolygonChanges').style.display = 'none';
                document.getElementById('cancelPolygonChanges').style.display = 'none';
                document.getElementById('editPolygon').style.display = 'block';
                document.getElementById('drawNewPolygon').style.display = 'block';
                document.getElementById('addVertex').style.display = 'block';
                
                // Ocultar indicador de modo de edición e instrucciones
                document.querySelector('.editing-mode-indicator').style.display = 'none';
                document.querySelector('.edit-instructions').style.display = 'none';
                window.editingMode = false;  // Usar window.editingMode para asegurar alcance global
                window.addVertexMode = false; // Resetear modo de agregar vértices
                
                // Restaurar el estilo original del polígono
                editableLayers.eachLayer(function(layer) {
                    if (layer instanceof L.Polygon) {
                        layer.setStyle({color: '#0066cc', weight: 3, fillOpacity: 0.2});
                    }
                });
                
                // Reactivar botones del formulario
                var formInputs = document.querySelectorAll('#formEditarPoligono input, #formEditarPoligono textarea, #formEditarPoligono select');
                formInputs.forEach(function(input) {
                    input.removeAttribute('disabled');
                });
                
                // Reactivar botón de envío del formulario
                var submitButton = document.querySelector('#formEditarPoligono button[type="submit"]');
                if (submitButton) {
                    submitButton.removeAttribute('disabled');
                }
                
                // Actualizar coordenadas originales para futuras ediciones
                originalCoords = [...updatedLatLngs];
                
                // Limpiar e inicializar para preparar una nueva edición
                cleanupLeafletDrawControls();
                
                // Reiniciar el botón de edición para asegurarnos que funciona correctamente
                reiniciarBotonEdicion();
                
                // Mantener actualizados los campos - evitar que se restauren valores previos
                setTimeout(function() {
                    // Verificar y restaurar los valores si fueron cambiados
                    verifyAndRestoreFields();
                }, 100);
                
                alert('Geometría actualizada correctamente');
                
                // Limpiar cualquier control de edición nativo que pueda haber aparecido
                setTimeout(cleanupLeafletDrawControls, 100);
                setTimeout(cleanupLeafletDrawControls, 500);
                setTimeout(cleanupLeafletDrawControls, 1000);
                setTimeout(reiniciarBotonEdicion, 1200);
                
                return false; // Evitar cualquier comportamiento adicional
            });
            
            // Manejar el evento de cancelar cambios
            document.getElementById('cancelPolygonChanges').addEventListener('click', function(e) {
                // Detener inmediatamente cualquier comportamiento predeterminado
                if (e && e.preventDefault) e.preventDefault();
                if (e && e.stopPropagation) e.stopPropagation();
                
                // Si estamos en modo dibujo, desactivarlo
                if (drawControl && drawingMode) {
                    drawControl.disable();
                    drawControl = null;
                    drawingMode = false;
                }
                
                // Desactivar editor personalizado
                if (customEditor) {
                    customEditor.disable();
                    customEditor = null;
                }
                
                // Desactivar editor de agregar vértices si estaba activo
                if (addVertexEditor) {
                    addVertexEditor.disable();
                    addVertexEditor = null;
                }
                
                // Desactivar editor personalizado de vértices si estaba activo
                if (window.customEditor) {
                    window.customEditor.disable();
                    window.customEditor = null;
                }
                
                // Eliminar el polígono actual
                editableLayers.clearLayers();
                
                // Recrear el polígono con las coordenadas originales
                polygon = L.polygon(originalCoords, {color: '#0066cc'});
                editableLayers.addLayer(polygon);
                
                // Ocultar botones de guardar y cancelar, mostrar botones de editar y dibujar nuevo
                document.getElementById('savePolygonChanges').style.display = 'none';
                document.getElementById('cancelPolygonChanges').style.display = 'none';
                document.getElementById('editPolygon').style.display = 'block';
                document.getElementById('drawNewPolygon').style.display = 'block';
                document.getElementById('addVertex').style.display = 'block';
                
                // Ocultar indicador de modo de edición e instrucciones
                document.querySelector('.editing-mode-indicator').style.display = 'none';
                document.querySelector('.edit-instructions').style.display = 'none';
                window.editingMode = false;  // Usar window.editingMode para asegurar alcance global
                window.addVertexMode = false; // Resetear modo de agregar vértices
                
                // Reactivar botones del formulario
                var formInputs = document.querySelectorAll('#formEditarPoligono input, #formEditarPoligono textarea, #formEditarPoligono select');
                formInputs.forEach(function(input) {
                    input.removeAttribute('disabled');
                });
                
                // Reactivar botón de envío del formulario
                var submitButton = document.querySelector('#formEditarPoligono button[type="submit"]');
                if (submitButton) {
                    submitButton.removeAttribute('disabled');
                }
                
                // Limpiar e inicializar para preparar una nueva edición
                cleanupLeafletDrawControls();
                
                // Reiniciar el botón de edición para asegurarnos que funciona correctamente
                reiniciarBotonEdicion();
                
                alert('Cambios cancelados');
                
                // Limpiar cualquier control de edición nativo que pueda haber aparecido
                setTimeout(cleanupLeafletDrawControls, 100);
                setTimeout(cleanupLeafletDrawControls, 500);
                setTimeout(cleanupLeafletDrawControls, 1000);
                setTimeout(reiniciarBotonEdicion, 1200);
                
                return false; // Evitar cualquier comportamiento adicional
            });
            
            // Remover los manejadores de eventos de Leaflet.Draw para evitar comportamientos inesperados
            map.off('draw:edited');
            
            // Establecer un manejador para el evento resize para garantizar que el mapa siempre se muestre correctamente
            window.addEventListener('resize', function() {
                map.invalidateSize();
            });
            
            // Eventos para el modo de pantalla completa
            map.on('fullscreenchange', function () {
                if (map.isFullscreen()) {
                    console.log('Entrando en modo pantalla completa');
                    // Ajustar el mapa cuando está en pantalla completa
                    setTimeout(function() {
                        map.invalidateSize();
                        if (polygon) {
                            map.fitBounds(polygon.getBounds());
                        }
                    }, 200);
                } else {
                    console.log('Saliendo del modo pantalla completa');
                    // Ajustar el mapa cuando sale de pantalla completa
                    setTimeout(function() {
                        map.invalidateSize();
                        if (polygon) {
                            map.fitBounds(polygon.getBounds());
                        }
                    }, 200);
                }
            });
            
            // Inicializar el botón de edición al cargar la página
            setTimeout(reiniciarBotonEdicion, 300);
            
            // Event listeners para controles de visibilidad de capas
            var toggleHistoricos = document.getElementById('toggleHistoricos');
            var toggleActuales = document.getElementById('toggleActuales');
            var togglePoligonoActual = document.getElementById('togglePoligonoActual');
            var zoomToPoligono = document.getElementById('zoomToPoligono');
            
            if (toggleHistoricos) {
                toggleHistoricos.addEventListener('change', function() {
                    if (this.checked) {
                        map.addLayer(historicoLayerGroup);
                    } else {
                        map.removeLayer(historicoLayerGroup);
                    }
                });
            }
            
            if (toggleActuales) {
                toggleActuales.addEventListener('change', function() {
                    if (this.checked) {
                        map.addLayer(actualesLayerGroup);
                    } else {
                        map.removeLayer(actualesLayerGroup);
                    }
                });
            }
            
            if (togglePoligonoActual) {
                togglePoligonoActual.addEventListener('change', function() {
                    if (this.checked) {
                        map.addLayer(poligonoActualLayer);
                    } else {
                        map.removeLayer(poligonoActualLayer);
                    }
                });
            }
            
            if (zoomToPoligono) {
                zoomToPoligono.addEventListener('click', function() {
                    // Hacer zoom al polígono actual si existe
                    if (polygon && polygon.getBounds) {
                        map.fitBounds(polygon.getBounds(), {padding: [20, 20]});
                    } else if (editableLayers.getLayers().length > 0) {
                        // Si hay capas en editableLayers, hacer zoom a esas
                        map.fitBounds(editableLayers.getBounds(), {padding: [20, 20]});
                    } else {
                        console.log("No hay polígono actual para hacer zoom");
                        
                        // Mostrar toast informativo
                        var toastHTML = `
                        <div class="toast-container position-fixed bottom-0 end-0 p-3">
                          <div class="toast show" role="alert" aria-live="assertive" aria-atomic="true">
                            <div class="toast-header">
                              <strong class="me-auto">Información</strong>
                              <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
                            </div>
                            <div class="toast-body">
                              No hay un polígono actual visible en el mapa.
                            </div>
                          </div>
                        </div>`;
                        
                        var toastDiv = document.createElement('div');
                        toastDiv.innerHTML = toastHTML;
                        document.body.appendChild(toastDiv);
                        
                        setTimeout(function() {
                            toastDiv.remove();
                        }, 3000);
                    }
                });
            }
            
            // Función para limpiar los controles no deseados de Leaflet.Draw
            function cleanupLeafletDrawControls() {
                // Ocultar cualquier control de edición nativo que pueda haber aparecido
                var leafletDrawControls = document.querySelectorAll('.leaflet-draw');
                leafletDrawControls.forEach(function(control) {
                    control.style.display = 'none';
                });
                
                // Asegurarse de que nuestros controles personalizados están visibles
                var editPolygonBtn = document.getElementById('editPolygon');
                var drawNewPolygonBtn = document.getElementById('drawNewPolygon');
                var addVertexBtn = document.getElementById('addVertex');
                if (editPolygonBtn && !editingMode && !window.addVertexMode) {
                    editPolygonBtn.style.display = 'block';
                }
                if (drawNewPolygonBtn && !editingMode && !window.addVertexMode) {
                    drawNewPolygonBtn.style.display = 'block';
                }
                if (addVertexBtn && !editingMode && !window.addVertexMode) {
                    addVertexBtn.style.display = 'block';
                }
                
                // Ocultar cualquier otro control de edición que pueda aparecer
                document.querySelectorAll('.leaflet-draw-edit-edit, .leaflet-draw-edit-remove').forEach(function(el) {
                    el.style.display = 'none';
                });
            }
        }
        
        document.getElementById('btnCancelar').addEventListener('click', function(e) {
            e.preventDefault(); // Prevenir comportamiento por defecto
            window.location.href = "{{ url_for('validacion_poligonos', tab='lista') }}";
        });

        // Botón "Guardar y pasar a siguiente registro"
        document.getElementById('btnGuardarSiguiente').addEventListener('click', function(e) {
            e.preventDefault(); // Prevenir comportamiento por defecto
            
            // Verificar si hay ediciones pendientes del polígono
            if (window.editingMode === true) {
                alert('Por favor guarde o cancele la edición del polígono antes de continuar.');
                return;
            }
            
            // Obtener el formulario
            var form = document.getElementById('formEditarPoligono');
            if (!form) {
                alert('Error: No se encontró el formulario.');
                return;
            }
            
            // Cambiar el texto del botón para mostrar progreso
            var btnSiguiente = document.getElementById('btnGuardarSiguiente');
            var textoOriginal = btnSiguiente.innerHTML;
            btnSiguiente.innerHTML = '<i class="bi bi-hourglass-split"></i> Guardando y pasando al siguiente...';
            btnSiguiente.disabled = true;
            
            // Agregar un campo oculto para indicar que queremos ir al siguiente registro
            var hiddenInput = document.createElement('input');
            hiddenInput.type = 'hidden';
            hiddenInput.name = 'guardar_y_siguiente';
            hiddenInput.value = 'true';
            form.appendChild(hiddenInput);
            
            // Mostrar un mensaje temporal
            var toastHTML = `
            <div class="toast-container position-fixed bottom-0 end-0 p-3">
              <div class="toast show" role="alert" aria-live="assertive" aria-atomic="true">
                <div class="toast-header">
                  <strong class="me-auto">Procesando</strong>
                  <small>Ahora</small>
                </div>
                <div class="toast-body">
                  <div class="d-flex align-items-center">
                    <div class="spinner-border spinner-border-sm me-2" role="status"></div>
                    <span>Guardando cambios y pasando al siguiente registro...</span>
                  </div>
                </div>
              </div>
            </div>`;
            
            var toastDiv = document.createElement('div');
            toastDiv.innerHTML = toastHTML;
            document.body.appendChild(toastDiv);
            
            // Timeout de seguridad para restaurar el botón si algo falla
            setTimeout(function() {
                btnSiguiente.innerHTML = textoOriginal;
                btnSiguiente.disabled = false;
                if (toastDiv.parentNode) {
                    toastDiv.parentNode.removeChild(toastDiv);
                }
            }, 5000);
            
            // Enviar el formulario
            form.submit();
        });

        // Función para calcular y actualizar automáticamente el Estatus basado en la diferencia de áreas
        function calcularEstatus() {
            var areaReportada = parseFloat(document.getElementById('Area_reportada').value) || 0;
            var areaDigitalizada = parseFloat(document.getElementById('Area_digitalizada').value) || 0;
            
            // Si alguna de las áreas es 0, no hacer nada (probablemente datos incompletos)
            if (areaReportada === 0 || areaDigitalizada === 0) return;
            
            // Calcular la diferencia porcentual relativa entre las áreas
            var diferencia = Math.abs(areaReportada - areaDigitalizada);
            var porcentajeDiferencia = (diferencia / areaReportada) * 100;
            
            // Seleccionar el radio button basado en la diferencia
            if (porcentajeDiferencia <= 11) {
                document.getElementById('Estatus7').checked = true;
            } else {
                document.getElementById('Estatus6').checked = true;
            }
            
            // Buscar el contenedor de Estatus de manera confiable
            var estatusContainer = null;
            
            // Buscar todas las etiquetas form-label y encontrar la que contiene "Estatus"
            var labels = document.querySelectorAll('.form-label');
            for (var i = 0; i < labels.length; i++) {
                if (labels[i].textContent.trim() === 'Estatus') {
                    estatusContainer = labels[i].closest('.col-12');
                    break;
                }
            }
            
            // Si no se encontró, intentar con el segundo método
            if (!estatusContainer) {
                var estatusInputs = document.querySelectorAll('input[name="ESTATUS"]');
                if (estatusInputs.length > 0) {
                    estatusContainer = estatusInputs[0].closest('.col-12');
                }
            }
            
            if (estatusContainer) {
                // Buscar o crear el elemento para mostrar el porcentaje
                var infoSpan = document.getElementById('diferenciaPorcentaje');
                if (!infoSpan) {
                    infoSpan = document.createElement('span');
                    infoSpan.id = 'diferenciaPorcentaje';
                    infoSpan.className = 'ms-2 badge bg-info';
                    
                    // Insertar después de la primera etiqueta del formulario dentro del contenedor
                    var firstLabel = estatusContainer.querySelector('label.form-label');
                    if (firstLabel) {
                        firstLabel.parentNode.insertBefore(infoSpan, firstLabel.nextSibling);
                    } else {
                        // Si no hay etiqueta, añadir al inicio del contenedor
                        estatusContainer.insertBefore(infoSpan, estatusContainer.firstChild);
                    }
                }
                
                // Actualizar siempre el contenido independientemente de si se creó o ya existía
                infoSpan.textContent = 'Diferencia: ' + porcentajeDiferencia.toFixed(2) + '%';
                
                // Actualizar el color de la insignia según el estado
                if (porcentajeDiferencia <= 11) {
                    infoSpan.className = 'ms-2 badge bg-success';
                } else {
                    infoSpan.className = 'ms-2 badge bg-warning text-dark';
                }
            } else {
                console.warn("No se pudo encontrar el contenedor de Estatus para mostrar la diferencia");
            }
        }
        
        // Ejecutar el cálculo cuando la página carga
        calcularEstatus();
        
        // Calcular el Estatus cuando cambian los valores de las áreas
        document.getElementById('Area_reportada').addEventListener('input', calcularEstatus);
        document.getElementById('Area_digitalizada').addEventListener('input', calcularEstatus);

        // Función para verificar y restaurar campos si fueron modificados
        function verifyAndRestoreFields() {
            var areaField = document.getElementById('Area_digitalizada');
            var coordsField = document.getElementById('COORDENADAS_DECIMALES_CORREGIDAS');
            
            // Restaurar valor de área si fue cambiado
            if (areaField && areaField.hasAttribute('data-polygon-area')) {
                var savedArea = areaField.getAttribute('data-polygon-area');
                if (areaField.value !== savedArea) {
                    console.log("Restaurando valor del área digitalizada:", savedArea);
                    areaField.value = savedArea;
                }
            }
            
            // Restaurar valor de coordenadas si fue cambiado
            if (coordsField && coordsField.hasAttribute('data-polygon-coords')) {
                var savedCoords = coordsField.getAttribute('data-polygon-coords');
                if (coordsField.value !== savedCoords) {
                    console.log("Restaurando valor de coordenadas:", savedCoords);
                    coordsField.value = savedCoords;
                }
            }
        }
        
        // Comprobar periódicamente que los valores no se pierdan
        setInterval(verifyAndRestoreFields, 1000);
    </script>
        
        {% elif tab == 'generar' %}

        <!-- Pestaña de Generar Fichas -->
        <div class="card">
            <div class="card-body">
                <h3 class="mb-4">Generar Fichas Técnicas</h3>
                
                {% if not data or not columns %}
                <div class="alert alert-warning">
                    No hay datos disponibles para generar fichas. Por favor, cargue un archivo Excel primero.
                </div>
                {% else %}
                <div class="alert alert-info">
                    Seleccione los registros para los que desea generar fichas técnicas y shapefiles.
                </div>
                
                <!-- Pestañas de visualización -->
                <div class="mb-4">
                    <ul class="nav nav-tabs">
                        <li class="nav-item">
                            <a class="nav-link active" id="vista-lote-tab" data-bs-toggle="tab" href="#vista-lote">Generación en Lote</a>
                        </li>
                    </ul>
                </div>
                
                <div class="tab-content">
                    <div class="tab-pane fade show active" id="vista-lote">
                        <div class="row mb-4">
                            <div class="col-md-4">
                                <label for="lote_fecha_referencia" class="form-label">Fecha de Referencia</label>
                                <input type="date" class="form-control" id="lote_fecha_referencia" name="fecha_referencia">
                            </div>
                            <div class="col-md-4">
                                <label for="lote_fecha_final" class="form-label">Fecha Final</label>
                                <input type="date" class="form-control" id="lote_fecha_final" name="fecha_final">
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="card mb-3">
                                <div class="card-header">
                                    <h5 class="mb-0">Seleccionar Polígonos</h5>
                                    <div class="btn-group mt-2">
                                        <button type="button" class="btn btn-sm btn-outline-primary" id="seleccionar-todos-lote">Seleccionar Todos</button>
                                        <button type="button" class="btn btn-sm btn-outline-success" id="seleccionar-estatus-7">Seleccionar Estatus 7</button>
                                    </div>
                                </div>
                                <div class="card-body polygon-selector" style="max-height: 400px; overflow-y: auto;">
                                    {% for row in data %}
                                    <div class="form-check mb-2">
                                        <input class="form-check-input lote-checkbox" type="checkbox" value="{{ row.db_id }}" id="polygon-{{ row.db_id }}">
                                        <label class="form-check-label" for="polygon-{{ row.db_id }}">
                                            {% if row.get('ID_POLIGONO') %}
                                                {{ row.get('ID_POLIGONO') }}
                                            {% else %}
                                                polygon-{{ row.db_id }}
                                            {% endif %}
                                            {% if row.get('ESTATUS') %}
                                                <small class="d-block mt-1">
                                                    <span class="badge 
                                                    {% if row.get('ESTATUS') == 'Válido' %}bg-success
                                                    {% elif row.get('ESTATUS') == 'Inválido' %}bg-danger
                                                    {% elif row.get('ESTATUS') == 'Revisar' %}bg-warning
                                                    {% else %}bg-secondary{% endif %}">
                                                        {{ row.get('ESTATUS') }}
                                                    </span>
                                                </small>
                                            {% endif %}
                                            {% if row.get('MUNICIPIO') and row.get('ESTADO') %}
                                            <small class="text-muted d-block">{{ row.get('MUNICIPIO') }}, {{ row.get('ESTADO') }}</small>
                                            {% endif %}
                                        </label>
                                    </div>
                                    {% endfor %}
                                </div>
                                <div class="card-footer">
                                    <div id="lote-seleccion-contador">1 polígonos seleccionados</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="col-md-8">
                            <div class="card">
                                <div class="card-body">
                                    <div class="d-flex align-items-center mb-3">
                                        <div class="check-circle bg-primary text-white">
                                            <i class="bi bi-check"></i>
                                        </div>
                                        <h5 class="ms-2 mb-0">Previsualización de Lote</h5>
                                    </div>
                                    
                                    <p>Se generarán <span id="count-fichas">1</span> fichas técnicas y archivos SHP. El resultado se organizará en:</p>
                                    
                                    <div class="row mb-4">
                                        <div class="col-md-6">
                                            <div class="export-preview p-3 border rounded">
                                                <div class="d-flex align-items-center mb-2">
                                                    <i class="bi bi-folder text-primary me-2" style="font-size: 1.2rem;"></i>
                                                    <h6 class="mb-0">Carpeta de Fichas Técnicas</h6>
                                                </div>
                                                <p class="small text-muted mb-2">Contiene todas las fichas técnicas en formato PDF para cada polígono seleccionado.</p>
                                                <ul class="list-unstyled small ms-4 mb-0">
                                                    <li class="mb-1"><i class="bi bi-file-pdf text-danger me-1"></i> ficha_ID_POLIGONO.pdf</li>
                                                    <li class="mb-1"><i class="bi bi-file-pdf text-danger me-1"></i> ficha_ID_POLIGONO.pdf</li>
                                                    <li class="mb-1"><i class="bi bi-three-dots me-1"></i> ...</li>
                                                </ul>
                                            </div>
                                        </div>
                                        
                                        <div class="col-md-6">
                                            <div class="export-preview p-3 border rounded">
                                                <div class="d-flex align-items-center mb-2">
                                                    <i class="bi bi-folder text-success me-2" style="font-size: 1.2rem;"></i>
                                                    <h6 class="mb-0">Carpeta de Archivos SHP</h6>
                                                </div>
                                                <p class="small text-muted mb-2">Contiene los archivos SHP y sus correspondientes archivos comprimidos en ZIP para cada polígono.</p>
                                                <ul class="list-unstyled small ms-4 mb-0">
                                                    <li class="mb-1"><i class="bi bi-file-earmark me-1 text-success"></i> ID_POLIGONO.shp</li>
                                                    <li class="mb-1"><i class="bi bi-file-earmark-zip me-1 text-primary"></i> ID_POLIGONO.zip</li>
                                                    <li class="mb-1"><i class="bi bi-three-dots me-1"></i> ...</li>
                                                </ul>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div class="alert alert-info">
                                        <div class="d-flex">
                                            <i class="bi bi-info-circle me-2" style="font-size: 1.2rem;"></i>
                                            <div>
                                                <h6 class="mb-1">Información sobre archivos SHP</h6>
                                                <p class="small mb-0">Los archivos SHP (Shapefile) son un formato estándar para datos geoespaciales. Cada polígono se exportará como un archivo SHP con sus correspondientes archivos auxiliares (.shx, .dbf, .prj) comprimidos en un ZIP para facilitar su distribución.</p>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div class="d-flex justify-content-end mt-3">
                                        <a href="{{ url_for('generar_excel') }}" class="btn btn-success me-2">
                                            <i class="bi bi-file-earmark-excel me-1"></i> Generar Excel
                                        </a>
                                        <button type="button" id="btn-generar-shp-unico" class="btn btn-warning me-2">
                                            <i class="bi bi-map me-1"></i> Generar Shp File
                                        </button>
                                        <button type="button" id="btn-generar-lote" class="btn btn-primary">
                                            <i class="bi bi-file-earmark-zip me-1"></i> Generar Fichas en Lote
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                {% endif %}
            </div>
        </div>

        <style>
            .check-circle {
                width: 24px;
                height: 24px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            .export-preview {
                height: 100%;
                background-color: #f8f9fa;
            }
            .polygon-selector {
                border-top: 1px solid #dee2e6;
                border-bottom: 1px solid #dee2e6;
            }
        </style>

        <!-- Importar shpjs para generar shapefiles -->
        <script src="https://unpkg.com/shpjs@latest/dist/shp.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

        <script>
            document.addEventListener('DOMContentLoaded', function() {
                
                // Seleccionar todos en vista lote con botón
                const btnSeleccionarTodosLote = document.getElementById('seleccionar-todos-lote');
                if (btnSeleccionarTodosLote) {
                    btnSeleccionarTodosLote.addEventListener('click', function() {
                        const checkboxes = document.querySelectorAll('.lote-checkbox');
                        checkboxes.forEach(checkbox => {
                            checkbox.checked = true;
                        });
                        updateLoteSelectionCounter();
                    });
                }
                
                // Seleccionar solo estatus 7 con botón
                const btnSeleccionarEstatus7 = document.getElementById('seleccionar-estatus-7');
                if (btnSeleccionarEstatus7) {
                    btnSeleccionarEstatus7.addEventListener('click', function() {
                        // Primero deseleccionar todos
                        const allCheckboxes = document.querySelectorAll('.lote-checkbox');
                        allCheckboxes.forEach(checkbox => {
                            checkbox.checked = false;
                        });
                        
                        // Luego seleccionar solo los que tienen estatus 7
                        const checkboxLabels = document.querySelectorAll('.form-check-label');
                        checkboxLabels.forEach(label => {
                            const badgeElement = label.querySelector('.badge');
                            if (badgeElement && badgeElement.textContent.trim() === '7') {
                                // Obtener el id del polígono desde el atributo "for" del label
                                const polygonId = label.getAttribute('for');
                                // Encontrar y marcar el checkbox correspondiente
                                const checkbox = document.getElementById(polygonId);
                                if (checkbox) {
                                    checkbox.checked = true;
                                }
                            }
                        });
                        
                        // Actualizar contador
                        updateLoteSelectionCounter();
                    });
                }
                

                
                // Actualizar contador de selección lote
                function updateLoteSelectionCounter() {
                    const checkboxes = document.querySelectorAll('.lote-checkbox:checked');
                    const counter = document.getElementById('lote-seleccion-contador');
                    const countFichas = document.getElementById('count-fichas');
                    if (counter) {
                        counter.textContent = `${checkboxes.length} polígonos seleccionados`;
                    }
                    if (countFichas) {
                        countFichas.textContent = checkboxes.length;
                    }
                }
                

                
                // Escuchar cambios en checkboxes de lote
                const loteCheckboxes = document.querySelectorAll('.lote-checkbox');
                loteCheckboxes.forEach(checkbox => {
                    checkbox.addEventListener('change', updateLoteSelectionCounter);
                });
                
                // Inicializar contador
                updateLoteSelectionCounter();
                

                
                // Generar shapefile único
                const btnGenerarShpUnico = document.getElementById('btn-generar-shp-unico');
                if (btnGenerarShpUnico) {
                    btnGenerarShpUnico.addEventListener('click', function() {
                        const selectedRows = Array.from(document.querySelectorAll('.lote-checkbox:checked')).map(cb => cb.value);
                        
                        if (selectedRows.length === 0) {
                            alert('Por favor, seleccione al menos un polígono.');
                            return;
                        }
                        
                        generarShapefileUnico(selectedRows);
                    });
                }

                // Generar fichas en lote
                const btnGenerarLote = document.getElementById('btn-generar-lote');
                if (btnGenerarLote) {
                    btnGenerarLote.addEventListener('click', function() {
                        const selectedRows = Array.from(document.querySelectorAll('.lote-checkbox:checked')).map(cb => cb.value);
                        
                        if (selectedRows.length === 0) {
                            alert('Por favor, seleccione al menos un polígono.');
                            return;
                        }
                        
                        // Preguntar al usuario qué tipo de ficha técnica quiere generar
                        const usarPlantilla = confirm("¿Desea generar las fichas técnicas con la nueva plantilla? \n\nSi selecciona 'Cancelar' se usará el formato tradicional.");
                        
                        if (usarPlantilla) {
                            // Generar paquete completo con la nueva plantilla
                            generarPaqueteCompletoConPlantilla(selectedRows);
                        } else {
                            // Generar paquete completo con el formato tradicional
                            generarPaqueteCompleto(selectedRows);
                        }
                    });
                }

                // Función para generar paquete completo con la nueva plantilla
                function generarPaqueteCompletoConPlantilla(selectedRows) {
                    // Mostrar cargando
                    const loadingToast = mostrarCargando('Generando paquete completo con plantilla...');
                    
                    // Obtener las fechas seleccionadas de la vista de lote
                    let fechaReferencia = '';
                    let fechaFinal = '';
                    
                    try {
                        // Siempre tomar los valores de la vista de lote (ya que es la única que queda)
                        const fechaRefElement = document.getElementById('lote_fecha_referencia');
                        const fechaFinElement = document.getElementById('lote_fecha_final');
                        
                        fechaReferencia = fechaRefElement ? fechaRefElement.value : '';
                        fechaFinal = fechaFinElement ? fechaFinElement.value : '';
                        console.log('Tomando fechas de vista lote:', fechaReferencia, fechaFinal);
                    } catch (error) {
                        console.error('Error al obtener fechas:', error);
                    }
                    
                    fetch('/generar_paquete_completo_con_plantilla', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ 
                            selected_rows: selectedRows,
                            fecha_referencia: fechaReferencia,
                            fecha_final: fechaFinal
                        })
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Error al generar paquete completo');
                        }
                        return response.blob();
                    })
                    .then(blob => {
                        // Ocultar cargando
                        ocultarCargando(loadingToast);
                        
                        // Descargar el archivo ZIP
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'paquete_completo_con_plantilla.zip';
                        document.body.appendChild(a);
                        a.click();
                        window.URL.revokeObjectURL(url);
                        document.body.removeChild(a);
                        
                        mostrarMensajeExito('Paquete completo con plantilla generado correctamente');
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        ocultarCargando(loadingToast);
                        mostrarError('Error al generar paquete: ' + error.message);
                    });
                }
                
                // Función para generar shapefile único
                function generarShapefileUnico(selectedRows) {
                    // Mostrar cargando
                    const loadingToast = mostrarCargando('Generando Shapefile único...');
                    
                    fetch('/generar_shapefile_unico', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ selected_rows: selectedRows })
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Error al generar shapefile único');
                        }
                        return response.blob();
                    })
                    .then(blob => {
                        // Ocultar cargando
                        ocultarCargando(loadingToast);
                        
                        // Descargar el archivo ZIP
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'poligonos_unificados.zip';
                        document.body.appendChild(a);
                        a.click();
                        window.URL.revokeObjectURL(url);
                        document.body.removeChild(a);
                        
                        mostrarMensajeExito('Shapefile único generado correctamente');
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        ocultarCargando(loadingToast);
                        mostrarError('Error al generar shapefile único: ' + error.message);
                    });
                }

                // Función para generar shapefiles (solo SHP)
                function generarShapefiles(selectedRows) {
                    // Mostrar cargando
                    const loadingToast = mostrarCargando('Generando Shapefiles...');
                    
                    fetch('/generar_shapefiles', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ selected_rows: selectedRows })
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Error al generar shapefiles');
                        }
                        return response.blob();
                    })
                    .then(blob => {
                        // Ocultar cargando
                        ocultarCargando(loadingToast);
                        
                        // Descargar el archivo ZIP
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'poligonos_shapefiles.zip';
                        document.body.appendChild(a);
                        a.click();
                        window.URL.revokeObjectURL(url);
                        document.body.removeChild(a);
                        
                        mostrarMensajeExito('Shapefiles generados correctamente');
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        ocultarCargando(loadingToast);
                        mostrarError('Error al generar shapefiles: ' + error.message);
                    });
                }
                
                // Función para generar shapefiles con mapas PNG
                function generarShapefilesConMapas(selectedRows) {
                    // Mostrar cargando
                    const loadingToast = mostrarCargando('Generando Shapefiles y Mapas PNG...');
                    
                    fetch('/generar_shapefiles_y_mapas', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ selected_rows: selectedRows })
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Error al generar shapefiles y mapas');
                        }
                        return response.blob();
                    })
                    .then(blob => {
                        // Ocultar cargando
                        ocultarCargando(loadingToast);
                        
                        // Descargar el archivo ZIP
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'poligonos_shapefiles_y_mapas.zip';
                        document.body.appendChild(a);
                        a.click();
                        window.URL.revokeObjectURL(url);
                        document.body.removeChild(a);
                        
                        mostrarMensajeExito('Shapefiles y mapas PNG generados correctamente');
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        ocultarCargando(loadingToast);
                        mostrarError('Error al generar shapefiles y mapas: ' + error.message);
                    });
                }
                
                // Función para generar paquete completo (PDF + SHP)
                function generarPaqueteCompleto(selectedRows) {
                    // Mostrar cargando
                    const loadingToast = mostrarCargando('Generando paquete completo...');
                    
                    fetch('/generar_paquete_completo', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ selected_rows: selectedRows })
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Error al generar paquete completo');
                        }
                        return response.blob();
                    })
                    .then(blob => {
                        // Ocultar cargando
                        ocultarCargando(loadingToast);
                        
                        // Descargar el archivo ZIP
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'paquete_completo.zip';
                        document.body.appendChild(a);
                        a.click();
                        window.URL.revokeObjectURL(url);
                        document.body.removeChild(a);
                        
                        mostrarMensajeExito('Paquete completo generado correctamente');
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        ocultarCargando(loadingToast);
                        mostrarError('Error al generar paquete: ' + error.message);
                    });
                }
                
                // Utilidades para mostrar notificaciones
                function mostrarCargando(mensaje) {
                    const toastContainer = document.createElement('div');
                    toastContainer.className = 'toast-container position-fixed bottom-0 end-0 p-3';
                    toastContainer.innerHTML = `
                    <div class="toast show" role="alert" aria-live="assertive" aria-atomic="true">
                        <div class="toast-header">
                            <strong class="me-auto">Procesando</strong>
                            <small>Ahora</small>
                        </div>
                        <div class="toast-body">
                            <div class="d-flex align-items-center">
                                <div class="spinner-border spinner-border-sm me-2" role="status"></div>
                                <span>${mensaje}</span>
                            </div>
                        </div>
                    </div>`;
                    document.body.appendChild(toastContainer);
                    return toastContainer;
                }
                
                function ocultarCargando(toastContainer) {
                    if (toastContainer && toastContainer.parentNode) {
                        toastContainer.parentNode.removeChild(toastContainer);
                    }
                }
                
                function mostrarMensajeExito(mensaje) {
                    const toastContainer = document.createElement('div');
                    toastContainer.className = 'toast-container position-fixed bottom-0 end-0 p-3';
                    toastContainer.innerHTML = `
                    <div class="toast show" role="alert" aria-live="assertive" aria-atomic="true">
                        <div class="toast-header">
                            <strong class="me-auto text-success">Éxito</strong>
                            <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
                        </div>
                        <div class="toast-body">
                            <i class="bi bi-check-circle text-success me-2"></i> ${mensaje}
                        </div>
                    </div>`;
                    document.body.appendChild(toastContainer);
                    setTimeout(() => {
                        if (toastContainer.parentNode) {
                            toastContainer.parentNode.removeChild(toastContainer);
                        }
                    }, 5000);
                }
                
                function mostrarError(mensaje) {
                    const toastContainer = document.createElement('div');
                    toastContainer.className = 'toast-container position-fixed bottom-0 end-0 p-3';
                    toastContainer.innerHTML = `
                    <div class="toast show" role="alert" aria-live="assertive" aria-atomic="true">
                        <div class="toast-header">
                            <strong class="me-auto text-danger">Error</strong>
                            <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
                        </div>
                        <div class="toast-body">
                            <i class="bi bi-exclamation-triangle text-danger me-2"></i> ${mensaje}
                        </div>
                    </div>`;
                    document.body.appendChild(toastContainer);
                    setTimeout(() => {
                        if (toastContainer.parentNode) {
                            toastContainer.parentNode.removeChild(toastContainer);
                        }
                    }, 5000);
                }
            });
        </script>
</code_block_to_apply_changes_from>
{% endif %}
{% endblock %}